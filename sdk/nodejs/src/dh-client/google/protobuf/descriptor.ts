/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 0.0.0
 * source: google/protobuf/descriptor.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class FileDescriptorSet extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        file: FileDescriptorProto[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.file = data.file;
        }
    }
    get file() {
        return pb_1.Message.getRepeatedWrapperField(this, FileDescriptorProto, 1) as FileDescriptorProto[];
    }
    set file(value: FileDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        file?: ReturnType<typeof FileDescriptorProto.prototype.toObject>[];
    }): FileDescriptorSet {
        const message = new FileDescriptorSet({
            file: data.file.map(item => FileDescriptorProto.fromObject(item))
        });
        return message;
    }
    toObject() {
        const data: {
            file?: ReturnType<typeof FileDescriptorProto.prototype.toObject>[];
        } = {};
        if (this.file != null) {
            data.file = this.file.map((item: FileDescriptorProto) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.file.length)
            writer.writeRepeatedMessage(1, this.file, (item: FileDescriptorProto) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileDescriptorSet {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileDescriptorSet();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.file, () => pb_1.Message.addToRepeatedWrapperField(message, 1, FileDescriptorProto.deserialize(reader), FileDescriptorProto));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileDescriptorSet {
        return FileDescriptorSet.deserialize(bytes);
    }
}
export class FileDescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        package?: string;
        dependency: string[];
        publicDependency: number[];
        weakDependency: number[];
        messageType: DescriptorProto[];
        enumType: EnumDescriptorProto[];
        service: ServiceDescriptorProto[];
        extension: FieldDescriptorProto[];
        options?: FileOptions;
        sourceCodeInfo?: SourceCodeInfo;
        syntax?: string;
        edition?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 10, 11, 4, 5, 6, 7], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("package" in data && data.package != undefined) {
                this.package = data.package;
            }
            this.dependency = data.dependency;
            this.publicDependency = data.publicDependency;
            this.weakDependency = data.weakDependency;
            this.messageType = data.messageType;
            this.enumType = data.enumType;
            this.service = data.service;
            this.extension = data.extension;
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
            if ("sourceCodeInfo" in data && data.sourceCodeInfo != undefined) {
                this.sourceCodeInfo = data.sourceCodeInfo;
            }
            if ("syntax" in data && data.syntax != undefined) {
                this.syntax = data.syntax;
            }
            if ("edition" in data && data.edition != undefined) {
                this.edition = data.edition;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get package() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set package(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasPackage() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get dependency() {
        return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
    }
    set dependency(value: string[]) {
        pb_1.Message.setField(this, 3, value);
    }
    get publicDependency() {
        return pb_1.Message.getFieldWithDefault(this, 10, []) as number[];
    }
    set publicDependency(value: number[]) {
        pb_1.Message.setField(this, 10, value);
    }
    get weakDependency() {
        return pb_1.Message.getFieldWithDefault(this, 11, []) as number[];
    }
    set weakDependency(value: number[]) {
        pb_1.Message.setField(this, 11, value);
    }
    get messageType() {
        return pb_1.Message.getRepeatedWrapperField(this, DescriptorProto, 4) as DescriptorProto[];
    }
    set messageType(value: DescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get enumType() {
        return pb_1.Message.getRepeatedWrapperField(this, EnumDescriptorProto, 5) as EnumDescriptorProto[];
    }
    set enumType(value: EnumDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get service() {
        return pb_1.Message.getRepeatedWrapperField(this, ServiceDescriptorProto, 6) as ServiceDescriptorProto[];
    }
    set service(value: ServiceDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    get extension() {
        return pb_1.Message.getRepeatedWrapperField(this, FieldDescriptorProto, 7) as FieldDescriptorProto[];
    }
    set extension(value: FieldDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 7, value);
    }
    get options() {
        return pb_1.Message.getWrapperField(this, FileOptions, 8) as FileOptions;
    }
    set options(value: FileOptions) {
        pb_1.Message.setWrapperField(this, 8, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get sourceCodeInfo() {
        return pb_1.Message.getWrapperField(this, SourceCodeInfo, 9) as SourceCodeInfo;
    }
    set sourceCodeInfo(value: SourceCodeInfo) {
        pb_1.Message.setWrapperField(this, 9, value);
    }
    get hasSourceCodeInfo() {
        return pb_1.Message.getField(this, 9) != null;
    }
    get syntax() {
        return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
    }
    set syntax(value: string) {
        pb_1.Message.setField(this, 12, value);
    }
    get hasSyntax() {
        return pb_1.Message.getField(this, 12) != null;
    }
    get edition() {
        return pb_1.Message.getFieldWithDefault(this, 13, "") as string;
    }
    set edition(value: string) {
        pb_1.Message.setField(this, 13, value);
    }
    get hasEdition() {
        return pb_1.Message.getField(this, 13) != null;
    }
    static fromObject(data: {
        name?: string;
        package?: string;
        dependency: string[];
        publicDependency: number[];
        weakDependency: number[];
        messageType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
        enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
        service?: ReturnType<typeof ServiceDescriptorProto.prototype.toObject>[];
        extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
        options?: ReturnType<typeof FileOptions.prototype.toObject>;
        sourceCodeInfo?: ReturnType<typeof SourceCodeInfo.prototype.toObject>;
        syntax?: string;
        edition?: string;
    }): FileDescriptorProto {
        const message = new FileDescriptorProto({
            dependency: data.dependency,
            publicDependency: data.publicDependency,
            weakDependency: data.weakDependency,
            messageType: data.messageType.map(item => DescriptorProto.fromObject(item)),
            enumType: data.enumType.map(item => EnumDescriptorProto.fromObject(item)),
            service: data.service.map(item => ServiceDescriptorProto.fromObject(item)),
            extension: data.extension.map(item => FieldDescriptorProto.fromObject(item))
        });
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.package != null) {
            message.package = data.package;
        }
        if (data.options != null) {
            message.options = FileOptions.fromObject(data.options);
        }
        if (data.sourceCodeInfo != null) {
            message.sourceCodeInfo = SourceCodeInfo.fromObject(data.sourceCodeInfo);
        }
        if (data.syntax != null) {
            message.syntax = data.syntax;
        }
        if (data.edition != null) {
            message.edition = data.edition;
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            package?: string;
            dependency: string[];
            publicDependency: number[];
            weakDependency: number[];
            messageType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
            enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
            service?: ReturnType<typeof ServiceDescriptorProto.prototype.toObject>[];
            extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof FileOptions.prototype.toObject>;
            sourceCodeInfo?: ReturnType<typeof SourceCodeInfo.prototype.toObject>;
            syntax?: string;
            edition?: string;
        } = {
            dependency: this.dependency,
            publicDependency: this.publicDependency,
            weakDependency: this.weakDependency
        };
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.package != null) {
            data.package = this.package;
        }
        if (this.messageType != null) {
            data.messageType = this.messageType.map((item: DescriptorProto) => item.toObject());
        }
        if (this.enumType != null) {
            data.enumType = this.enumType.map((item: EnumDescriptorProto) => item.toObject());
        }
        if (this.service != null) {
            data.service = this.service.map((item: ServiceDescriptorProto) => item.toObject());
        }
        if (this.extension != null) {
            data.extension = this.extension.map((item: FieldDescriptorProto) => item.toObject());
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        if (this.sourceCodeInfo != null) {
            data.sourceCodeInfo = this.sourceCodeInfo.toObject();
        }
        if (this.syntax != null) {
            data.syntax = this.syntax;
        }
        if (this.edition != null) {
            data.edition = this.edition;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.hasPackage && this.package.length)
            writer.writeString(2, this.package);
        if (this.dependency.length)
            writer.writeRepeatedString(3, this.dependency);
        if (this.publicDependency.length)
            writer.writeRepeatedInt32(10, this.publicDependency);
        if (this.weakDependency.length)
            writer.writeRepeatedInt32(11, this.weakDependency);
        if (this.messageType.length)
            writer.writeRepeatedMessage(4, this.messageType, (item: DescriptorProto) => item.serialize(writer));
        if (this.enumType.length)
            writer.writeRepeatedMessage(5, this.enumType, (item: EnumDescriptorProto) => item.serialize(writer));
        if (this.service.length)
            writer.writeRepeatedMessage(6, this.service, (item: ServiceDescriptorProto) => item.serialize(writer));
        if (this.extension.length)
            writer.writeRepeatedMessage(7, this.extension, (item: FieldDescriptorProto) => item.serialize(writer));
        if (this.hasOptions)
            writer.writeMessage(8, this.options, () => this.options.serialize(writer));
        if (this.hasSourceCodeInfo)
            writer.writeMessage(9, this.sourceCodeInfo, () => this.sourceCodeInfo.serialize(writer));
        if (this.hasSyntax && this.syntax.length)
            writer.writeString(12, this.syntax);
        if (this.hasEdition && this.edition.length)
            writer.writeString(13, this.edition);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileDescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileDescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    message.package = reader.readString();
                    break;
                case 3:
                    pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                    break;
                case 10:
                    pb_1.Message.addToRepeatedField(message, 10, reader.readInt32());
                    break;
                case 11:
                    pb_1.Message.addToRepeatedField(message, 11, reader.readInt32());
                    break;
                case 4:
                    reader.readMessage(message.messageType, () => pb_1.Message.addToRepeatedWrapperField(message, 4, DescriptorProto.deserialize(reader), DescriptorProto));
                    break;
                case 5:
                    reader.readMessage(message.enumType, () => pb_1.Message.addToRepeatedWrapperField(message, 5, EnumDescriptorProto.deserialize(reader), EnumDescriptorProto));
                    break;
                case 6:
                    reader.readMessage(message.service, () => pb_1.Message.addToRepeatedWrapperField(message, 6, ServiceDescriptorProto.deserialize(reader), ServiceDescriptorProto));
                    break;
                case 7:
                    reader.readMessage(message.extension, () => pb_1.Message.addToRepeatedWrapperField(message, 7, FieldDescriptorProto.deserialize(reader), FieldDescriptorProto));
                    break;
                case 8:
                    reader.readMessage(message.options, () => message.options = FileOptions.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.sourceCodeInfo, () => message.sourceCodeInfo = SourceCodeInfo.deserialize(reader));
                    break;
                case 12:
                    message.syntax = reader.readString();
                    break;
                case 13:
                    message.edition = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileDescriptorProto {
        return FileDescriptorProto.deserialize(bytes);
    }
}
export class DescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        field: FieldDescriptorProto[];
        extension: FieldDescriptorProto[];
        nestedType: DescriptorProto[];
        enumType: EnumDescriptorProto[];
        extensionRange: DescriptorProtoExtensionRange[];
        oneofDecl: OneofDescriptorProto[];
        options?: MessageOptions;
        reservedRange: DescriptorProtoReservedRange[];
        reservedName: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 6, 3, 4, 5, 8, 9, 10], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            this.field = data.field;
            this.extension = data.extension;
            this.nestedType = data.nestedType;
            this.enumType = data.enumType;
            this.extensionRange = data.extensionRange;
            this.oneofDecl = data.oneofDecl;
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
            this.reservedRange = data.reservedRange;
            this.reservedName = data.reservedName;
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get field() {
        return pb_1.Message.getRepeatedWrapperField(this, FieldDescriptorProto, 2) as FieldDescriptorProto[];
    }
    set field(value: FieldDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get extension() {
        return pb_1.Message.getRepeatedWrapperField(this, FieldDescriptorProto, 6) as FieldDescriptorProto[];
    }
    set extension(value: FieldDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    get nestedType() {
        return pb_1.Message.getRepeatedWrapperField(this, DescriptorProto, 3) as DescriptorProto[];
    }
    set nestedType(value: DescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get enumType() {
        return pb_1.Message.getRepeatedWrapperField(this, EnumDescriptorProto, 4) as EnumDescriptorProto[];
    }
    set enumType(value: EnumDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get extensionRange() {
        return pb_1.Message.getRepeatedWrapperField(this, DescriptorProtoExtensionRange, 5) as DescriptorProtoExtensionRange[];
    }
    set extensionRange(value: DescriptorProtoExtensionRange[]) {
        pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get oneofDecl() {
        return pb_1.Message.getRepeatedWrapperField(this, OneofDescriptorProto, 8) as OneofDescriptorProto[];
    }
    set oneofDecl(value: OneofDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 8, value);
    }
    get options() {
        return pb_1.Message.getWrapperField(this, MessageOptions, 7) as MessageOptions;
    }
    set options(value: MessageOptions) {
        pb_1.Message.setWrapperField(this, 7, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 7) != null;
    }
    get reservedRange() {
        return pb_1.Message.getRepeatedWrapperField(this, DescriptorProtoReservedRange, 9) as DescriptorProtoReservedRange[];
    }
    set reservedRange(value: DescriptorProtoReservedRange[]) {
        pb_1.Message.setRepeatedWrapperField(this, 9, value);
    }
    get reservedName() {
        return pb_1.Message.getFieldWithDefault(this, 10, []) as string[];
    }
    set reservedName(value: string[]) {
        pb_1.Message.setField(this, 10, value);
    }
    static fromObject(data: {
        name?: string;
        field?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
        extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
        nestedType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
        enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
        extensionRange?: ReturnType<typeof DescriptorProtoExtensionRange.prototype.toObject>[];
        oneofDecl?: ReturnType<typeof OneofDescriptorProto.prototype.toObject>[];
        options?: ReturnType<typeof MessageOptions.prototype.toObject>;
        reservedRange?: ReturnType<typeof DescriptorProtoReservedRange.prototype.toObject>[];
        reservedName: string[];
    }): DescriptorProto {
        const message = new DescriptorProto({
            field: data.field.map(item => FieldDescriptorProto.fromObject(item)),
            extension: data.extension.map(item => FieldDescriptorProto.fromObject(item)),
            nestedType: data.nestedType.map(item => DescriptorProto.fromObject(item)),
            enumType: data.enumType.map(item => EnumDescriptorProto.fromObject(item)),
            extensionRange: data.extensionRange.map(item => DescriptorProtoExtensionRange.fromObject(item)),
            oneofDecl: data.oneofDecl.map(item => OneofDescriptorProto.fromObject(item)),
            reservedRange: data.reservedRange.map(item => DescriptorProtoReservedRange.fromObject(item)),
            reservedName: data.reservedName
        });
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.options != null) {
            message.options = MessageOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            field?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
            extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
            nestedType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
            enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
            extensionRange?: ReturnType<typeof DescriptorProtoExtensionRange.prototype.toObject>[];
            oneofDecl?: ReturnType<typeof OneofDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof MessageOptions.prototype.toObject>;
            reservedRange?: ReturnType<typeof DescriptorProtoReservedRange.prototype.toObject>[];
            reservedName: string[];
        } = {
            reservedName: this.reservedName
        };
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.field != null) {
            data.field = this.field.map((item: FieldDescriptorProto) => item.toObject());
        }
        if (this.extension != null) {
            data.extension = this.extension.map((item: FieldDescriptorProto) => item.toObject());
        }
        if (this.nestedType != null) {
            data.nestedType = this.nestedType.map((item: DescriptorProto) => item.toObject());
        }
        if (this.enumType != null) {
            data.enumType = this.enumType.map((item: EnumDescriptorProto) => item.toObject());
        }
        if (this.extensionRange != null) {
            data.extensionRange = this.extensionRange.map((item: DescriptorProtoExtensionRange) => item.toObject());
        }
        if (this.oneofDecl != null) {
            data.oneofDecl = this.oneofDecl.map((item: OneofDescriptorProto) => item.toObject());
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        if (this.reservedRange != null) {
            data.reservedRange = this.reservedRange.map((item: DescriptorProtoReservedRange) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.field.length)
            writer.writeRepeatedMessage(2, this.field, (item: FieldDescriptorProto) => item.serialize(writer));
        if (this.extension.length)
            writer.writeRepeatedMessage(6, this.extension, (item: FieldDescriptorProto) => item.serialize(writer));
        if (this.nestedType.length)
            writer.writeRepeatedMessage(3, this.nestedType, (item: DescriptorProto) => item.serialize(writer));
        if (this.enumType.length)
            writer.writeRepeatedMessage(4, this.enumType, (item: EnumDescriptorProto) => item.serialize(writer));
        if (this.extensionRange.length)
            writer.writeRepeatedMessage(5, this.extensionRange, (item: DescriptorProtoExtensionRange) => item.serialize(writer));
        if (this.oneofDecl.length)
            writer.writeRepeatedMessage(8, this.oneofDecl, (item: OneofDescriptorProto) => item.serialize(writer));
        if (this.hasOptions)
            writer.writeMessage(7, this.options, () => this.options.serialize(writer));
        if (this.reservedRange.length)
            writer.writeRepeatedMessage(9, this.reservedRange, (item: DescriptorProtoReservedRange) => item.serialize(writer));
        if (this.reservedName.length)
            writer.writeRepeatedString(10, this.reservedName);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.field, () => pb_1.Message.addToRepeatedWrapperField(message, 2, FieldDescriptorProto.deserialize(reader), FieldDescriptorProto));
                    break;
                case 6:
                    reader.readMessage(message.extension, () => pb_1.Message.addToRepeatedWrapperField(message, 6, FieldDescriptorProto.deserialize(reader), FieldDescriptorProto));
                    break;
                case 3:
                    reader.readMessage(message.nestedType, () => pb_1.Message.addToRepeatedWrapperField(message, 3, DescriptorProto.deserialize(reader), DescriptorProto));
                    break;
                case 4:
                    reader.readMessage(message.enumType, () => pb_1.Message.addToRepeatedWrapperField(message, 4, EnumDescriptorProto.deserialize(reader), EnumDescriptorProto));
                    break;
                case 5:
                    reader.readMessage(message.extensionRange, () => pb_1.Message.addToRepeatedWrapperField(message, 5, DescriptorProtoExtensionRange.deserialize(reader), DescriptorProtoExtensionRange));
                    break;
                case 8:
                    reader.readMessage(message.oneofDecl, () => pb_1.Message.addToRepeatedWrapperField(message, 8, OneofDescriptorProto.deserialize(reader), OneofDescriptorProto));
                    break;
                case 7:
                    reader.readMessage(message.options, () => message.options = MessageOptions.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.reservedRange, () => pb_1.Message.addToRepeatedWrapperField(message, 9, DescriptorProtoReservedRange.deserialize(reader), DescriptorProtoReservedRange));
                    break;
                case 10:
                    pb_1.Message.addToRepeatedField(message, 10, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DescriptorProto {
        return DescriptorProto.deserialize(bytes);
    }
}
export class DescriptorProtoExtensionRange extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        start?: number;
        end?: number;
        options?: ExtensionRangeOptions;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("start" in data && data.start != undefined) {
                this.start = data.start;
            }
            if ("end" in data && data.end != undefined) {
                this.end = data.end;
            }
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
        }
    }
    get start() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set start(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasStart() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get end() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set end(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasEnd() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get options() {
        return pb_1.Message.getWrapperField(this, ExtensionRangeOptions, 3) as ExtensionRangeOptions;
    }
    set options(value: ExtensionRangeOptions) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
        start?: number;
        end?: number;
        options?: ReturnType<typeof ExtensionRangeOptions.prototype.toObject>;
    }): DescriptorProtoExtensionRange {
        const message = new DescriptorProtoExtensionRange({});
        if (data.start != null) {
            message.start = data.start;
        }
        if (data.end != null) {
            message.end = data.end;
        }
        if (data.options != null) {
            message.options = ExtensionRangeOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data: {
            start?: number;
            end?: number;
            options?: ReturnType<typeof ExtensionRangeOptions.prototype.toObject>;
        } = {};
        if (this.start != null) {
            data.start = this.start;
        }
        if (this.end != null) {
            data.end = this.end;
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasStart)
            writer.writeInt32(1, this.start);
        if (this.hasEnd)
            writer.writeInt32(2, this.end);
        if (this.hasOptions)
            writer.writeMessage(3, this.options, () => this.options.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DescriptorProtoExtensionRange {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DescriptorProtoExtensionRange();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.start = reader.readInt32();
                    break;
                case 2:
                    message.end = reader.readInt32();
                    break;
                case 3:
                    reader.readMessage(message.options, () => message.options = ExtensionRangeOptions.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DescriptorProtoExtensionRange {
        return DescriptorProtoExtensionRange.deserialize(bytes);
    }
}
export class DescriptorProtoReservedRange extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        start?: number;
        end?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("start" in data && data.start != undefined) {
                this.start = data.start;
            }
            if ("end" in data && data.end != undefined) {
                this.end = data.end;
            }
        }
    }
    get start() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set start(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasStart() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get end() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set end(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasEnd() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        start?: number;
        end?: number;
    }): DescriptorProtoReservedRange {
        const message = new DescriptorProtoReservedRange({});
        if (data.start != null) {
            message.start = data.start;
        }
        if (data.end != null) {
            message.end = data.end;
        }
        return message;
    }
    toObject() {
        const data: {
            start?: number;
            end?: number;
        } = {};
        if (this.start != null) {
            data.start = this.start;
        }
        if (this.end != null) {
            data.end = this.end;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasStart)
            writer.writeInt32(1, this.start);
        if (this.hasEnd)
            writer.writeInt32(2, this.end);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DescriptorProtoReservedRange {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DescriptorProtoReservedRange();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.start = reader.readInt32();
                    break;
                case 2:
                    message.end = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DescriptorProtoReservedRange {
        return DescriptorProtoReservedRange.deserialize(bytes);
    }
}
export class ExtensionRangeOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): ExtensionRangeOptions {
        const message = new ExtensionRangeOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        return message;
    }
    toObject() {
        const data: {
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExtensionRangeOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExtensionRangeOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ExtensionRangeOptions {
        return ExtensionRangeOptions.deserialize(bytes);
    }
}
export class FieldDescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        number?: number;
        label?: FieldDescriptorProtoLabel;
        type?: FieldDescriptorProtoType;
        typeName?: string;
        extendee?: string;
        defaultValue?: string;
        oneofIndex?: number;
        jsonName?: string;
        options?: FieldOptions;
        proto3Optional?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("number" in data && data.number != undefined) {
                this.number = data.number;
            }
            if ("label" in data && data.label != undefined) {
                this.label = data.label;
            }
            if ("type" in data && data.type != undefined) {
                this.type = data.type;
            }
            if ("typeName" in data && data.typeName != undefined) {
                this.typeName = data.typeName;
            }
            if ("extendee" in data && data.extendee != undefined) {
                this.extendee = data.extendee;
            }
            if ("defaultValue" in data && data.defaultValue != undefined) {
                this.defaultValue = data.defaultValue;
            }
            if ("oneofIndex" in data && data.oneofIndex != undefined) {
                this.oneofIndex = data.oneofIndex;
            }
            if ("jsonName" in data && data.jsonName != undefined) {
                this.jsonName = data.jsonName;
            }
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
            if ("proto3Optional" in data && data.proto3Optional != undefined) {
                this.proto3Optional = data.proto3Optional;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get number() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set number(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasNumber() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get label() {
        return pb_1.Message.getFieldWithDefault(this, 4, FieldDescriptorProtoLabel.LABEL_OPTIONAL) as FieldDescriptorProtoLabel;
    }
    set label(value: FieldDescriptorProtoLabel) {
        pb_1.Message.setField(this, 4, value);
    }
    get hasLabel() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get type() {
        return pb_1.Message.getFieldWithDefault(this, 5, FieldDescriptorProtoType.TYPE_DOUBLE) as FieldDescriptorProtoType;
    }
    set type(value: FieldDescriptorProtoType) {
        pb_1.Message.setField(this, 5, value);
    }
    get hasType() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get typeName() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set typeName(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get hasTypeName() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get extendee() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set extendee(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasExtendee() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get defaultValue() {
        return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set defaultValue(value: string) {
        pb_1.Message.setField(this, 7, value);
    }
    get hasDefaultValue() {
        return pb_1.Message.getField(this, 7) != null;
    }
    get oneofIndex() {
        return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
    }
    set oneofIndex(value: number) {
        pb_1.Message.setField(this, 9, value);
    }
    get hasOneofIndex() {
        return pb_1.Message.getField(this, 9) != null;
    }
    get jsonName() {
        return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
    }
    set jsonName(value: string) {
        pb_1.Message.setField(this, 10, value);
    }
    get hasJsonName() {
        return pb_1.Message.getField(this, 10) != null;
    }
    get options() {
        return pb_1.Message.getWrapperField(this, FieldOptions, 8) as FieldOptions;
    }
    set options(value: FieldOptions) {
        pb_1.Message.setWrapperField(this, 8, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get proto3Optional() {
        return pb_1.Message.getFieldWithDefault(this, 17, false) as boolean;
    }
    set proto3Optional(value: boolean) {
        pb_1.Message.setField(this, 17, value);
    }
    get hasProto3Optional() {
        return pb_1.Message.getField(this, 17) != null;
    }
    static fromObject(data: {
        name?: string;
        number?: number;
        label?: FieldDescriptorProtoLabel;
        type?: FieldDescriptorProtoType;
        typeName?: string;
        extendee?: string;
        defaultValue?: string;
        oneofIndex?: number;
        jsonName?: string;
        options?: ReturnType<typeof FieldOptions.prototype.toObject>;
        proto3Optional?: boolean;
    }): FieldDescriptorProto {
        const message = new FieldDescriptorProto({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.number != null) {
            message.number = data.number;
        }
        if (data.label != null) {
            message.label = data.label;
        }
        if (data.type != null) {
            message.type = data.type;
        }
        if (data.typeName != null) {
            message.typeName = data.typeName;
        }
        if (data.extendee != null) {
            message.extendee = data.extendee;
        }
        if (data.defaultValue != null) {
            message.defaultValue = data.defaultValue;
        }
        if (data.oneofIndex != null) {
            message.oneofIndex = data.oneofIndex;
        }
        if (data.jsonName != null) {
            message.jsonName = data.jsonName;
        }
        if (data.options != null) {
            message.options = FieldOptions.fromObject(data.options);
        }
        if (data.proto3Optional != null) {
            message.proto3Optional = data.proto3Optional;
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            number?: number;
            label?: FieldDescriptorProtoLabel;
            type?: FieldDescriptorProtoType;
            typeName?: string;
            extendee?: string;
            defaultValue?: string;
            oneofIndex?: number;
            jsonName?: string;
            options?: ReturnType<typeof FieldOptions.prototype.toObject>;
            proto3Optional?: boolean;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.number != null) {
            data.number = this.number;
        }
        if (this.label != null) {
            data.label = this.label;
        }
        if (this.type != null) {
            data.type = this.type;
        }
        if (this.typeName != null) {
            data.typeName = this.typeName;
        }
        if (this.extendee != null) {
            data.extendee = this.extendee;
        }
        if (this.defaultValue != null) {
            data.defaultValue = this.defaultValue;
        }
        if (this.oneofIndex != null) {
            data.oneofIndex = this.oneofIndex;
        }
        if (this.jsonName != null) {
            data.jsonName = this.jsonName;
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        if (this.proto3Optional != null) {
            data.proto3Optional = this.proto3Optional;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.hasNumber)
            writer.writeInt32(3, this.number);
        if (this.hasLabel)
            writer.writeEnum(4, this.label);
        if (this.hasType)
            writer.writeEnum(5, this.type);
        if (this.hasTypeName && this.typeName.length)
            writer.writeString(6, this.typeName);
        if (this.hasExtendee && this.extendee.length)
            writer.writeString(2, this.extendee);
        if (this.hasDefaultValue && this.defaultValue.length)
            writer.writeString(7, this.defaultValue);
        if (this.hasOneofIndex)
            writer.writeInt32(9, this.oneofIndex);
        if (this.hasJsonName && this.jsonName.length)
            writer.writeString(10, this.jsonName);
        if (this.hasOptions)
            writer.writeMessage(8, this.options, () => this.options.serialize(writer));
        if (this.hasProto3Optional)
            writer.writeBool(17, this.proto3Optional);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FieldDescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FieldDescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 3:
                    message.number = reader.readInt32();
                    break;
                case 4:
                    message.label = reader.readEnum();
                    break;
                case 5:
                    message.type = reader.readEnum();
                    break;
                case 6:
                    message.typeName = reader.readString();
                    break;
                case 2:
                    message.extendee = reader.readString();
                    break;
                case 7:
                    message.defaultValue = reader.readString();
                    break;
                case 9:
                    message.oneofIndex = reader.readInt32();
                    break;
                case 10:
                    message.jsonName = reader.readString();
                    break;
                case 8:
                    reader.readMessage(message.options, () => message.options = FieldOptions.deserialize(reader));
                    break;
                case 17:
                    message.proto3Optional = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FieldDescriptorProto {
        return FieldDescriptorProto.deserialize(bytes);
    }
}
export enum FieldDescriptorProtoType {
    TYPE_DOUBLE = 1,
    TYPE_FLOAT = 2,
    TYPE_INT64 = 3,
    TYPE_UINT64 = 4,
    TYPE_INT32 = 5,
    TYPE_FIXED64 = 6,
    TYPE_FIXED32 = 7,
    TYPE_BOOL = 8,
    TYPE_STRING = 9,
    TYPE_GROUP = 10,
    TYPE_MESSAGE = 11,
    TYPE_BYTES = 12,
    TYPE_UINT32 = 13,
    TYPE_ENUM = 14,
    TYPE_SFIXED32 = 15,
    TYPE_SFIXED64 = 16,
    TYPE_SINT32 = 17,
    TYPE_SINT64 = 18
}
export enum FieldDescriptorProtoLabel {
    LABEL_OPTIONAL = 1,
    LABEL_REQUIRED = 2,
    LABEL_REPEATED = 3
}
export class OneofDescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        options?: OneofOptions;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get options() {
        return pb_1.Message.getWrapperField(this, OneofOptions, 2) as OneofOptions;
    }
    set options(value: OneofOptions) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        name?: string;
        options?: ReturnType<typeof OneofOptions.prototype.toObject>;
    }): OneofDescriptorProto {
        const message = new OneofDescriptorProto({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.options != null) {
            message.options = OneofOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            options?: ReturnType<typeof OneofOptions.prototype.toObject>;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.hasOptions)
            writer.writeMessage(2, this.options, () => this.options.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OneofDescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OneofDescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.options, () => message.options = OneofOptions.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OneofDescriptorProto {
        return OneofDescriptorProto.deserialize(bytes);
    }
}
export class EnumDescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        value: EnumValueDescriptorProto[];
        options?: EnumOptions;
        reservedRange: EnumDescriptorProtoEnumReservedRange[];
        reservedName: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 4, 5], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            this.value = data.value;
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
            this.reservedRange = data.reservedRange;
            this.reservedName = data.reservedName;
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get value() {
        return pb_1.Message.getRepeatedWrapperField(this, EnumValueDescriptorProto, 2) as EnumValueDescriptorProto[];
    }
    set value(value: EnumValueDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get options() {
        return pb_1.Message.getWrapperField(this, EnumOptions, 3) as EnumOptions;
    }
    set options(value: EnumOptions) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get reservedRange() {
        return pb_1.Message.getRepeatedWrapperField(this, EnumDescriptorProtoEnumReservedRange, 4) as EnumDescriptorProtoEnumReservedRange[];
    }
    set reservedRange(value: EnumDescriptorProtoEnumReservedRange[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get reservedName() {
        return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
    }
    set reservedName(value: string[]) {
        pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
        name?: string;
        value?: ReturnType<typeof EnumValueDescriptorProto.prototype.toObject>[];
        options?: ReturnType<typeof EnumOptions.prototype.toObject>;
        reservedRange?: ReturnType<typeof EnumDescriptorProtoEnumReservedRange.prototype.toObject>[];
        reservedName: string[];
    }): EnumDescriptorProto {
        const message = new EnumDescriptorProto({
            value: data.value.map(item => EnumValueDescriptorProto.fromObject(item)),
            reservedRange: data.reservedRange.map(item => EnumDescriptorProtoEnumReservedRange.fromObject(item)),
            reservedName: data.reservedName
        });
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.options != null) {
            message.options = EnumOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            value?: ReturnType<typeof EnumValueDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof EnumOptions.prototype.toObject>;
            reservedRange?: ReturnType<typeof EnumDescriptorProtoEnumReservedRange.prototype.toObject>[];
            reservedName: string[];
        } = {
            reservedName: this.reservedName
        };
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.value != null) {
            data.value = this.value.map((item: EnumValueDescriptorProto) => item.toObject());
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        if (this.reservedRange != null) {
            data.reservedRange = this.reservedRange.map((item: EnumDescriptorProtoEnumReservedRange) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.value.length)
            writer.writeRepeatedMessage(2, this.value, (item: EnumValueDescriptorProto) => item.serialize(writer));
        if (this.hasOptions)
            writer.writeMessage(3, this.options, () => this.options.serialize(writer));
        if (this.reservedRange.length)
            writer.writeRepeatedMessage(4, this.reservedRange, (item: EnumDescriptorProtoEnumReservedRange) => item.serialize(writer));
        if (this.reservedName.length)
            writer.writeRepeatedString(5, this.reservedName);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumDescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumDescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.value, () => pb_1.Message.addToRepeatedWrapperField(message, 2, EnumValueDescriptorProto.deserialize(reader), EnumValueDescriptorProto));
                    break;
                case 3:
                    reader.readMessage(message.options, () => message.options = EnumOptions.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.reservedRange, () => pb_1.Message.addToRepeatedWrapperField(message, 4, EnumDescriptorProtoEnumReservedRange.deserialize(reader), EnumDescriptorProtoEnumReservedRange));
                    break;
                case 5:
                    pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EnumDescriptorProto {
        return EnumDescriptorProto.deserialize(bytes);
    }
}
export class EnumDescriptorProtoEnumReservedRange extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        start?: number;
        end?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("start" in data && data.start != undefined) {
                this.start = data.start;
            }
            if ("end" in data && data.end != undefined) {
                this.end = data.end;
            }
        }
    }
    get start() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set start(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasStart() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get end() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set end(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasEnd() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        start?: number;
        end?: number;
    }): EnumDescriptorProtoEnumReservedRange {
        const message = new EnumDescriptorProtoEnumReservedRange({});
        if (data.start != null) {
            message.start = data.start;
        }
        if (data.end != null) {
            message.end = data.end;
        }
        return message;
    }
    toObject() {
        const data: {
            start?: number;
            end?: number;
        } = {};
        if (this.start != null) {
            data.start = this.start;
        }
        if (this.end != null) {
            data.end = this.end;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasStart)
            writer.writeInt32(1, this.start);
        if (this.hasEnd)
            writer.writeInt32(2, this.end);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumDescriptorProtoEnumReservedRange {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumDescriptorProtoEnumReservedRange();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.start = reader.readInt32();
                    break;
                case 2:
                    message.end = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EnumDescriptorProtoEnumReservedRange {
        return EnumDescriptorProtoEnumReservedRange.deserialize(bytes);
    }
}
export class EnumValueDescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        number?: number;
        options?: EnumValueOptions;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("number" in data && data.number != undefined) {
                this.number = data.number;
            }
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get number() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set number(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasNumber() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get options() {
        return pb_1.Message.getWrapperField(this, EnumValueOptions, 3) as EnumValueOptions;
    }
    set options(value: EnumValueOptions) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
        name?: string;
        number?: number;
        options?: ReturnType<typeof EnumValueOptions.prototype.toObject>;
    }): EnumValueDescriptorProto {
        const message = new EnumValueDescriptorProto({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.number != null) {
            message.number = data.number;
        }
        if (data.options != null) {
            message.options = EnumValueOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            number?: number;
            options?: ReturnType<typeof EnumValueOptions.prototype.toObject>;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.number != null) {
            data.number = this.number;
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.hasNumber)
            writer.writeInt32(2, this.number);
        if (this.hasOptions)
            writer.writeMessage(3, this.options, () => this.options.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumValueDescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumValueDescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    message.number = reader.readInt32();
                    break;
                case 3:
                    reader.readMessage(message.options, () => message.options = EnumValueOptions.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EnumValueDescriptorProto {
        return EnumValueDescriptorProto.deserialize(bytes);
    }
}
export class ServiceDescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        method: MethodDescriptorProto[];
        options?: ServiceOptions;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            this.method = data.method;
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get method() {
        return pb_1.Message.getRepeatedWrapperField(this, MethodDescriptorProto, 2) as MethodDescriptorProto[];
    }
    set method(value: MethodDescriptorProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get options() {
        return pb_1.Message.getWrapperField(this, ServiceOptions, 3) as ServiceOptions;
    }
    set options(value: ServiceOptions) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
        name?: string;
        method?: ReturnType<typeof MethodDescriptorProto.prototype.toObject>[];
        options?: ReturnType<typeof ServiceOptions.prototype.toObject>;
    }): ServiceDescriptorProto {
        const message = new ServiceDescriptorProto({
            method: data.method.map(item => MethodDescriptorProto.fromObject(item))
        });
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.options != null) {
            message.options = ServiceOptions.fromObject(data.options);
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            method?: ReturnType<typeof MethodDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof ServiceOptions.prototype.toObject>;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.method != null) {
            data.method = this.method.map((item: MethodDescriptorProto) => item.toObject());
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.method.length)
            writer.writeRepeatedMessage(2, this.method, (item: MethodDescriptorProto) => item.serialize(writer));
        if (this.hasOptions)
            writer.writeMessage(3, this.options, () => this.options.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ServiceDescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ServiceDescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.method, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MethodDescriptorProto.deserialize(reader), MethodDescriptorProto));
                    break;
                case 3:
                    reader.readMessage(message.options, () => message.options = ServiceOptions.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ServiceDescriptorProto {
        return ServiceDescriptorProto.deserialize(bytes);
    }
}
export class MethodDescriptorProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        inputType?: string;
        outputType?: string;
        options?: MethodOptions;
        clientStreaming?: boolean;
        serverStreaming?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("inputType" in data && data.inputType != undefined) {
                this.inputType = data.inputType;
            }
            if ("outputType" in data && data.outputType != undefined) {
                this.outputType = data.outputType;
            }
            if ("options" in data && data.options != undefined) {
                this.options = data.options;
            }
            if ("clientStreaming" in data && data.clientStreaming != undefined) {
                this.clientStreaming = data.clientStreaming;
            }
            if ("serverStreaming" in data && data.serverStreaming != undefined) {
                this.serverStreaming = data.serverStreaming;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get inputType() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set inputType(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasInputType() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get outputType() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set outputType(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasOutputType() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get options() {
        return pb_1.Message.getWrapperField(this, MethodOptions, 4) as MethodOptions;
    }
    set options(value: MethodOptions) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get hasOptions() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get clientStreaming() {
        return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
    }
    set clientStreaming(value: boolean) {
        pb_1.Message.setField(this, 5, value);
    }
    get hasClientStreaming() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get serverStreaming() {
        return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
    }
    set serverStreaming(value: boolean) {
        pb_1.Message.setField(this, 6, value);
    }
    get hasServerStreaming() {
        return pb_1.Message.getField(this, 6) != null;
    }
    static fromObject(data: {
        name?: string;
        inputType?: string;
        outputType?: string;
        options?: ReturnType<typeof MethodOptions.prototype.toObject>;
        clientStreaming?: boolean;
        serverStreaming?: boolean;
    }): MethodDescriptorProto {
        const message = new MethodDescriptorProto({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.inputType != null) {
            message.inputType = data.inputType;
        }
        if (data.outputType != null) {
            message.outputType = data.outputType;
        }
        if (data.options != null) {
            message.options = MethodOptions.fromObject(data.options);
        }
        if (data.clientStreaming != null) {
            message.clientStreaming = data.clientStreaming;
        }
        if (data.serverStreaming != null) {
            message.serverStreaming = data.serverStreaming;
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            inputType?: string;
            outputType?: string;
            options?: ReturnType<typeof MethodOptions.prototype.toObject>;
            clientStreaming?: boolean;
            serverStreaming?: boolean;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.inputType != null) {
            data.inputType = this.inputType;
        }
        if (this.outputType != null) {
            data.outputType = this.outputType;
        }
        if (this.options != null) {
            data.options = this.options.toObject();
        }
        if (this.clientStreaming != null) {
            data.clientStreaming = this.clientStreaming;
        }
        if (this.serverStreaming != null) {
            data.serverStreaming = this.serverStreaming;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasName && this.name.length)
            writer.writeString(1, this.name);
        if (this.hasInputType && this.inputType.length)
            writer.writeString(2, this.inputType);
        if (this.hasOutputType && this.outputType.length)
            writer.writeString(3, this.outputType);
        if (this.hasOptions)
            writer.writeMessage(4, this.options, () => this.options.serialize(writer));
        if (this.hasClientStreaming)
            writer.writeBool(5, this.clientStreaming);
        if (this.hasServerStreaming)
            writer.writeBool(6, this.serverStreaming);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MethodDescriptorProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MethodDescriptorProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    message.inputType = reader.readString();
                    break;
                case 3:
                    message.outputType = reader.readString();
                    break;
                case 4:
                    reader.readMessage(message.options, () => message.options = MethodOptions.deserialize(reader));
                    break;
                case 5:
                    message.clientStreaming = reader.readBool();
                    break;
                case 6:
                    message.serverStreaming = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MethodDescriptorProto {
        return MethodDescriptorProto.deserialize(bytes);
    }
}
export class FileOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        javaPackage?: string;
        javaOuterClassname?: string;
        javaMultipleFiles?: boolean;
        /** @deprecated*/
        javaGenerateEqualsAndHash?: boolean;
        javaStringCheckUtf8?: boolean;
        optimizeFor?: FileOptionsOptimizeMode;
        goPackage?: string;
        ccGenericServices?: boolean;
        javaGenericServices?: boolean;
        pyGenericServices?: boolean;
        phpGenericServices?: boolean;
        deprecated?: boolean;
        ccEnableArenas?: boolean;
        objcClassPrefix?: string;
        csharpNamespace?: string;
        swiftPrefix?: string;
        phpClassPrefix?: string;
        phpNamespace?: string;
        phpMetadataNamespace?: string;
        rubyPackage?: string;
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("javaPackage" in data && data.javaPackage != undefined) {
                this.javaPackage = data.javaPackage;
            }
            if ("javaOuterClassname" in data && data.javaOuterClassname != undefined) {
                this.javaOuterClassname = data.javaOuterClassname;
            }
            if ("javaMultipleFiles" in data && data.javaMultipleFiles != undefined) {
                this.javaMultipleFiles = data.javaMultipleFiles;
            }
            if ("javaGenerateEqualsAndHash" in data && data.javaGenerateEqualsAndHash != undefined) {
                this.javaGenerateEqualsAndHash = data.javaGenerateEqualsAndHash;
            }
            if ("javaStringCheckUtf8" in data && data.javaStringCheckUtf8 != undefined) {
                this.javaStringCheckUtf8 = data.javaStringCheckUtf8;
            }
            if ("optimizeFor" in data && data.optimizeFor != undefined) {
                this.optimizeFor = data.optimizeFor;
            }
            if ("goPackage" in data && data.goPackage != undefined) {
                this.goPackage = data.goPackage;
            }
            if ("ccGenericServices" in data && data.ccGenericServices != undefined) {
                this.ccGenericServices = data.ccGenericServices;
            }
            if ("javaGenericServices" in data && data.javaGenericServices != undefined) {
                this.javaGenericServices = data.javaGenericServices;
            }
            if ("pyGenericServices" in data && data.pyGenericServices != undefined) {
                this.pyGenericServices = data.pyGenericServices;
            }
            if ("phpGenericServices" in data && data.phpGenericServices != undefined) {
                this.phpGenericServices = data.phpGenericServices;
            }
            if ("deprecated" in data && data.deprecated != undefined) {
                this.deprecated = data.deprecated;
            }
            if ("ccEnableArenas" in data && data.ccEnableArenas != undefined) {
                this.ccEnableArenas = data.ccEnableArenas;
            }
            if ("objcClassPrefix" in data && data.objcClassPrefix != undefined) {
                this.objcClassPrefix = data.objcClassPrefix;
            }
            if ("csharpNamespace" in data && data.csharpNamespace != undefined) {
                this.csharpNamespace = data.csharpNamespace;
            }
            if ("swiftPrefix" in data && data.swiftPrefix != undefined) {
                this.swiftPrefix = data.swiftPrefix;
            }
            if ("phpClassPrefix" in data && data.phpClassPrefix != undefined) {
                this.phpClassPrefix = data.phpClassPrefix;
            }
            if ("phpNamespace" in data && data.phpNamespace != undefined) {
                this.phpNamespace = data.phpNamespace;
            }
            if ("phpMetadataNamespace" in data && data.phpMetadataNamespace != undefined) {
                this.phpMetadataNamespace = data.phpMetadataNamespace;
            }
            if ("rubyPackage" in data && data.rubyPackage != undefined) {
                this.rubyPackage = data.rubyPackage;
            }
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get javaPackage() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set javaPackage(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasJavaPackage() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get javaOuterClassname() {
        return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set javaOuterClassname(value: string) {
        pb_1.Message.setField(this, 8, value);
    }
    get hasJavaOuterClassname() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get javaMultipleFiles() {
        return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
    }
    set javaMultipleFiles(value: boolean) {
        pb_1.Message.setField(this, 10, value);
    }
    get hasJavaMultipleFiles() {
        return pb_1.Message.getField(this, 10) != null;
    }
    /** @deprecated*/
    get javaGenerateEqualsAndHash() {
        return pb_1.Message.getFieldWithDefault(this, 20, false) as boolean;
    }
    /** @deprecated*/
    set javaGenerateEqualsAndHash(value: boolean) {
        pb_1.Message.setField(this, 20, value);
    }
    /** @deprecated*/
    get hasJavaGenerateEqualsAndHash() {
        return pb_1.Message.getField(this, 20) != null;
    }
    get javaStringCheckUtf8() {
        return pb_1.Message.getFieldWithDefault(this, 27, false) as boolean;
    }
    set javaStringCheckUtf8(value: boolean) {
        pb_1.Message.setField(this, 27, value);
    }
    get hasJavaStringCheckUtf8() {
        return pb_1.Message.getField(this, 27) != null;
    }
    get optimizeFor() {
        return pb_1.Message.getFieldWithDefault(this, 9, FileOptionsOptimizeMode.SPEED) as FileOptionsOptimizeMode;
    }
    set optimizeFor(value: FileOptionsOptimizeMode) {
        pb_1.Message.setField(this, 9, value);
    }
    get hasOptimizeFor() {
        return pb_1.Message.getField(this, 9) != null;
    }
    get goPackage() {
        return pb_1.Message.getFieldWithDefault(this, 11, "") as string;
    }
    set goPackage(value: string) {
        pb_1.Message.setField(this, 11, value);
    }
    get hasGoPackage() {
        return pb_1.Message.getField(this, 11) != null;
    }
    get ccGenericServices() {
        return pb_1.Message.getFieldWithDefault(this, 16, false) as boolean;
    }
    set ccGenericServices(value: boolean) {
        pb_1.Message.setField(this, 16, value);
    }
    get hasCcGenericServices() {
        return pb_1.Message.getField(this, 16) != null;
    }
    get javaGenericServices() {
        return pb_1.Message.getFieldWithDefault(this, 17, false) as boolean;
    }
    set javaGenericServices(value: boolean) {
        pb_1.Message.setField(this, 17, value);
    }
    get hasJavaGenericServices() {
        return pb_1.Message.getField(this, 17) != null;
    }
    get pyGenericServices() {
        return pb_1.Message.getFieldWithDefault(this, 18, false) as boolean;
    }
    set pyGenericServices(value: boolean) {
        pb_1.Message.setField(this, 18, value);
    }
    get hasPyGenericServices() {
        return pb_1.Message.getField(this, 18) != null;
    }
    get phpGenericServices() {
        return pb_1.Message.getFieldWithDefault(this, 42, false) as boolean;
    }
    set phpGenericServices(value: boolean) {
        pb_1.Message.setField(this, 42, value);
    }
    get hasPhpGenericServices() {
        return pb_1.Message.getField(this, 42) != null;
    }
    get deprecated() {
        return pb_1.Message.getFieldWithDefault(this, 23, false) as boolean;
    }
    set deprecated(value: boolean) {
        pb_1.Message.setField(this, 23, value);
    }
    get hasDeprecated() {
        return pb_1.Message.getField(this, 23) != null;
    }
    get ccEnableArenas() {
        return pb_1.Message.getFieldWithDefault(this, 31, true) as boolean;
    }
    set ccEnableArenas(value: boolean) {
        pb_1.Message.setField(this, 31, value);
    }
    get hasCcEnableArenas() {
        return pb_1.Message.getField(this, 31) != null;
    }
    get objcClassPrefix() {
        return pb_1.Message.getFieldWithDefault(this, 36, "") as string;
    }
    set objcClassPrefix(value: string) {
        pb_1.Message.setField(this, 36, value);
    }
    get hasObjcClassPrefix() {
        return pb_1.Message.getField(this, 36) != null;
    }
    get csharpNamespace() {
        return pb_1.Message.getFieldWithDefault(this, 37, "") as string;
    }
    set csharpNamespace(value: string) {
        pb_1.Message.setField(this, 37, value);
    }
    get hasCsharpNamespace() {
        return pb_1.Message.getField(this, 37) != null;
    }
    get swiftPrefix() {
        return pb_1.Message.getFieldWithDefault(this, 39, "") as string;
    }
    set swiftPrefix(value: string) {
        pb_1.Message.setField(this, 39, value);
    }
    get hasSwiftPrefix() {
        return pb_1.Message.getField(this, 39) != null;
    }
    get phpClassPrefix() {
        return pb_1.Message.getFieldWithDefault(this, 40, "") as string;
    }
    set phpClassPrefix(value: string) {
        pb_1.Message.setField(this, 40, value);
    }
    get hasPhpClassPrefix() {
        return pb_1.Message.getField(this, 40) != null;
    }
    get phpNamespace() {
        return pb_1.Message.getFieldWithDefault(this, 41, "") as string;
    }
    set phpNamespace(value: string) {
        pb_1.Message.setField(this, 41, value);
    }
    get hasPhpNamespace() {
        return pb_1.Message.getField(this, 41) != null;
    }
    get phpMetadataNamespace() {
        return pb_1.Message.getFieldWithDefault(this, 44, "") as string;
    }
    set phpMetadataNamespace(value: string) {
        pb_1.Message.setField(this, 44, value);
    }
    get hasPhpMetadataNamespace() {
        return pb_1.Message.getField(this, 44) != null;
    }
    get rubyPackage() {
        return pb_1.Message.getFieldWithDefault(this, 45, "") as string;
    }
    set rubyPackage(value: string) {
        pb_1.Message.setField(this, 45, value);
    }
    get hasRubyPackage() {
        return pb_1.Message.getField(this, 45) != null;
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        javaPackage?: string;
        javaOuterClassname?: string;
        javaMultipleFiles?: boolean;
        javaGenerateEqualsAndHash?: boolean;
        javaStringCheckUtf8?: boolean;
        optimizeFor?: FileOptionsOptimizeMode;
        goPackage?: string;
        ccGenericServices?: boolean;
        javaGenericServices?: boolean;
        pyGenericServices?: boolean;
        phpGenericServices?: boolean;
        deprecated?: boolean;
        ccEnableArenas?: boolean;
        objcClassPrefix?: string;
        csharpNamespace?: string;
        swiftPrefix?: string;
        phpClassPrefix?: string;
        phpNamespace?: string;
        phpMetadataNamespace?: string;
        rubyPackage?: string;
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): FileOptions {
        const message = new FileOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        if (data.javaPackage != null) {
            message.javaPackage = data.javaPackage;
        }
        if (data.javaOuterClassname != null) {
            message.javaOuterClassname = data.javaOuterClassname;
        }
        if (data.javaMultipleFiles != null) {
            message.javaMultipleFiles = data.javaMultipleFiles;
        }
        if (data.javaGenerateEqualsAndHash != null) {
            message.javaGenerateEqualsAndHash = data.javaGenerateEqualsAndHash;
        }
        if (data.javaStringCheckUtf8 != null) {
            message.javaStringCheckUtf8 = data.javaStringCheckUtf8;
        }
        if (data.optimizeFor != null) {
            message.optimizeFor = data.optimizeFor;
        }
        if (data.goPackage != null) {
            message.goPackage = data.goPackage;
        }
        if (data.ccGenericServices != null) {
            message.ccGenericServices = data.ccGenericServices;
        }
        if (data.javaGenericServices != null) {
            message.javaGenericServices = data.javaGenericServices;
        }
        if (data.pyGenericServices != null) {
            message.pyGenericServices = data.pyGenericServices;
        }
        if (data.phpGenericServices != null) {
            message.phpGenericServices = data.phpGenericServices;
        }
        if (data.deprecated != null) {
            message.deprecated = data.deprecated;
        }
        if (data.ccEnableArenas != null) {
            message.ccEnableArenas = data.ccEnableArenas;
        }
        if (data.objcClassPrefix != null) {
            message.objcClassPrefix = data.objcClassPrefix;
        }
        if (data.csharpNamespace != null) {
            message.csharpNamespace = data.csharpNamespace;
        }
        if (data.swiftPrefix != null) {
            message.swiftPrefix = data.swiftPrefix;
        }
        if (data.phpClassPrefix != null) {
            message.phpClassPrefix = data.phpClassPrefix;
        }
        if (data.phpNamespace != null) {
            message.phpNamespace = data.phpNamespace;
        }
        if (data.phpMetadataNamespace != null) {
            message.phpMetadataNamespace = data.phpMetadataNamespace;
        }
        if (data.rubyPackage != null) {
            message.rubyPackage = data.rubyPackage;
        }
        return message;
    }
    toObject() {
        const data: {
            javaPackage?: string;
            javaOuterClassname?: string;
            javaMultipleFiles?: boolean;
            javaGenerateEqualsAndHash?: boolean;
            javaStringCheckUtf8?: boolean;
            optimizeFor?: FileOptionsOptimizeMode;
            goPackage?: string;
            ccGenericServices?: boolean;
            javaGenericServices?: boolean;
            pyGenericServices?: boolean;
            phpGenericServices?: boolean;
            deprecated?: boolean;
            ccEnableArenas?: boolean;
            objcClassPrefix?: string;
            csharpNamespace?: string;
            swiftPrefix?: string;
            phpClassPrefix?: string;
            phpNamespace?: string;
            phpMetadataNamespace?: string;
            rubyPackage?: string;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.javaPackage != null) {
            data.javaPackage = this.javaPackage;
        }
        if (this.javaOuterClassname != null) {
            data.javaOuterClassname = this.javaOuterClassname;
        }
        if (this.javaMultipleFiles != null) {
            data.javaMultipleFiles = this.javaMultipleFiles;
        }
        if (this.javaGenerateEqualsAndHash != null) {
            data.javaGenerateEqualsAndHash = this.javaGenerateEqualsAndHash;
        }
        if (this.javaStringCheckUtf8 != null) {
            data.javaStringCheckUtf8 = this.javaStringCheckUtf8;
        }
        if (this.optimizeFor != null) {
            data.optimizeFor = this.optimizeFor;
        }
        if (this.goPackage != null) {
            data.goPackage = this.goPackage;
        }
        if (this.ccGenericServices != null) {
            data.ccGenericServices = this.ccGenericServices;
        }
        if (this.javaGenericServices != null) {
            data.javaGenericServices = this.javaGenericServices;
        }
        if (this.pyGenericServices != null) {
            data.pyGenericServices = this.pyGenericServices;
        }
        if (this.phpGenericServices != null) {
            data.phpGenericServices = this.phpGenericServices;
        }
        if (this.deprecated != null) {
            data.deprecated = this.deprecated;
        }
        if (this.ccEnableArenas != null) {
            data.ccEnableArenas = this.ccEnableArenas;
        }
        if (this.objcClassPrefix != null) {
            data.objcClassPrefix = this.objcClassPrefix;
        }
        if (this.csharpNamespace != null) {
            data.csharpNamespace = this.csharpNamespace;
        }
        if (this.swiftPrefix != null) {
            data.swiftPrefix = this.swiftPrefix;
        }
        if (this.phpClassPrefix != null) {
            data.phpClassPrefix = this.phpClassPrefix;
        }
        if (this.phpNamespace != null) {
            data.phpNamespace = this.phpNamespace;
        }
        if (this.phpMetadataNamespace != null) {
            data.phpMetadataNamespace = this.phpMetadataNamespace;
        }
        if (this.rubyPackage != null) {
            data.rubyPackage = this.rubyPackage;
        }
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasJavaPackage && this.javaPackage.length)
            writer.writeString(1, this.javaPackage);
        if (this.hasJavaOuterClassname && this.javaOuterClassname.length)
            writer.writeString(8, this.javaOuterClassname);
        if (this.hasJavaMultipleFiles)
            writer.writeBool(10, this.javaMultipleFiles);
        if (this.hasJavaGenerateEqualsAndHash)
            writer.writeBool(20, this.javaGenerateEqualsAndHash);
        if (this.hasJavaStringCheckUtf8)
            writer.writeBool(27, this.javaStringCheckUtf8);
        if (this.hasOptimizeFor)
            writer.writeEnum(9, this.optimizeFor);
        if (this.hasGoPackage && this.goPackage.length)
            writer.writeString(11, this.goPackage);
        if (this.hasCcGenericServices)
            writer.writeBool(16, this.ccGenericServices);
        if (this.hasJavaGenericServices)
            writer.writeBool(17, this.javaGenericServices);
        if (this.hasPyGenericServices)
            writer.writeBool(18, this.pyGenericServices);
        if (this.hasPhpGenericServices)
            writer.writeBool(42, this.phpGenericServices);
        if (this.hasDeprecated)
            writer.writeBool(23, this.deprecated);
        if (this.hasCcEnableArenas)
            writer.writeBool(31, this.ccEnableArenas);
        if (this.hasObjcClassPrefix && this.objcClassPrefix.length)
            writer.writeString(36, this.objcClassPrefix);
        if (this.hasCsharpNamespace && this.csharpNamespace.length)
            writer.writeString(37, this.csharpNamespace);
        if (this.hasSwiftPrefix && this.swiftPrefix.length)
            writer.writeString(39, this.swiftPrefix);
        if (this.hasPhpClassPrefix && this.phpClassPrefix.length)
            writer.writeString(40, this.phpClassPrefix);
        if (this.hasPhpNamespace && this.phpNamespace.length)
            writer.writeString(41, this.phpNamespace);
        if (this.hasPhpMetadataNamespace && this.phpMetadataNamespace.length)
            writer.writeString(44, this.phpMetadataNamespace);
        if (this.hasRubyPackage && this.rubyPackage.length)
            writer.writeString(45, this.rubyPackage);
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.javaPackage = reader.readString();
                    break;
                case 8:
                    message.javaOuterClassname = reader.readString();
                    break;
                case 10:
                    message.javaMultipleFiles = reader.readBool();
                    break;
                case 20:
                    message.javaGenerateEqualsAndHash = reader.readBool();
                    break;
                case 27:
                    message.javaStringCheckUtf8 = reader.readBool();
                    break;
                case 9:
                    message.optimizeFor = reader.readEnum();
                    break;
                case 11:
                    message.goPackage = reader.readString();
                    break;
                case 16:
                    message.ccGenericServices = reader.readBool();
                    break;
                case 17:
                    message.javaGenericServices = reader.readBool();
                    break;
                case 18:
                    message.pyGenericServices = reader.readBool();
                    break;
                case 42:
                    message.phpGenericServices = reader.readBool();
                    break;
                case 23:
                    message.deprecated = reader.readBool();
                    break;
                case 31:
                    message.ccEnableArenas = reader.readBool();
                    break;
                case 36:
                    message.objcClassPrefix = reader.readString();
                    break;
                case 37:
                    message.csharpNamespace = reader.readString();
                    break;
                case 39:
                    message.swiftPrefix = reader.readString();
                    break;
                case 40:
                    message.phpClassPrefix = reader.readString();
                    break;
                case 41:
                    message.phpNamespace = reader.readString();
                    break;
                case 44:
                    message.phpMetadataNamespace = reader.readString();
                    break;
                case 45:
                    message.rubyPackage = reader.readString();
                    break;
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileOptions {
        return FileOptions.deserialize(bytes);
    }
}
export enum FileOptionsOptimizeMode {
    SPEED = 1,
    CODE_SIZE = 2,
    LITE_RUNTIME = 3
}
export class MessageOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        messageSetWireFormat?: boolean;
        noStandardDescriptorAccessor?: boolean;
        deprecated?: boolean;
        mapEntry?: boolean;
        /** @deprecated*/
        deprecatedLegacyJsonFieldConflicts?: boolean;
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("messageSetWireFormat" in data && data.messageSetWireFormat != undefined) {
                this.messageSetWireFormat = data.messageSetWireFormat;
            }
            if ("noStandardDescriptorAccessor" in data && data.noStandardDescriptorAccessor != undefined) {
                this.noStandardDescriptorAccessor = data.noStandardDescriptorAccessor;
            }
            if ("deprecated" in data && data.deprecated != undefined) {
                this.deprecated = data.deprecated;
            }
            if ("mapEntry" in data && data.mapEntry != undefined) {
                this.mapEntry = data.mapEntry;
            }
            if ("deprecatedLegacyJsonFieldConflicts" in data && data.deprecatedLegacyJsonFieldConflicts != undefined) {
                this.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
            }
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get messageSetWireFormat() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set messageSetWireFormat(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasMessageSetWireFormat() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get noStandardDescriptorAccessor() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set noStandardDescriptorAccessor(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasNoStandardDescriptorAccessor() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get deprecated() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set deprecated(value: boolean) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasDeprecated() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get mapEntry() {
        return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
    }
    set mapEntry(value: boolean) {
        pb_1.Message.setField(this, 7, value);
    }
    get hasMapEntry() {
        return pb_1.Message.getField(this, 7) != null;
    }
    /** @deprecated*/
    get deprecatedLegacyJsonFieldConflicts() {
        return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
    }
    /** @deprecated*/
    set deprecatedLegacyJsonFieldConflicts(value: boolean) {
        pb_1.Message.setField(this, 11, value);
    }
    /** @deprecated*/
    get hasDeprecatedLegacyJsonFieldConflicts() {
        return pb_1.Message.getField(this, 11) != null;
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        messageSetWireFormat?: boolean;
        noStandardDescriptorAccessor?: boolean;
        deprecated?: boolean;
        mapEntry?: boolean;
        deprecatedLegacyJsonFieldConflicts?: boolean;
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): MessageOptions {
        const message = new MessageOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        if (data.messageSetWireFormat != null) {
            message.messageSetWireFormat = data.messageSetWireFormat;
        }
        if (data.noStandardDescriptorAccessor != null) {
            message.noStandardDescriptorAccessor = data.noStandardDescriptorAccessor;
        }
        if (data.deprecated != null) {
            message.deprecated = data.deprecated;
        }
        if (data.mapEntry != null) {
            message.mapEntry = data.mapEntry;
        }
        if (data.deprecatedLegacyJsonFieldConflicts != null) {
            message.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
        }
        return message;
    }
    toObject() {
        const data: {
            messageSetWireFormat?: boolean;
            noStandardDescriptorAccessor?: boolean;
            deprecated?: boolean;
            mapEntry?: boolean;
            deprecatedLegacyJsonFieldConflicts?: boolean;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.messageSetWireFormat != null) {
            data.messageSetWireFormat = this.messageSetWireFormat;
        }
        if (this.noStandardDescriptorAccessor != null) {
            data.noStandardDescriptorAccessor = this.noStandardDescriptorAccessor;
        }
        if (this.deprecated != null) {
            data.deprecated = this.deprecated;
        }
        if (this.mapEntry != null) {
            data.mapEntry = this.mapEntry;
        }
        if (this.deprecatedLegacyJsonFieldConflicts != null) {
            data.deprecatedLegacyJsonFieldConflicts = this.deprecatedLegacyJsonFieldConflicts;
        }
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasMessageSetWireFormat)
            writer.writeBool(1, this.messageSetWireFormat);
        if (this.hasNoStandardDescriptorAccessor)
            writer.writeBool(2, this.noStandardDescriptorAccessor);
        if (this.hasDeprecated)
            writer.writeBool(3, this.deprecated);
        if (this.hasMapEntry)
            writer.writeBool(7, this.mapEntry);
        if (this.hasDeprecatedLegacyJsonFieldConflicts)
            writer.writeBool(11, this.deprecatedLegacyJsonFieldConflicts);
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MessageOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MessageOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.messageSetWireFormat = reader.readBool();
                    break;
                case 2:
                    message.noStandardDescriptorAccessor = reader.readBool();
                    break;
                case 3:
                    message.deprecated = reader.readBool();
                    break;
                case 7:
                    message.mapEntry = reader.readBool();
                    break;
                case 11:
                    message.deprecatedLegacyJsonFieldConflicts = reader.readBool();
                    break;
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MessageOptions {
        return MessageOptions.deserialize(bytes);
    }
}
export class FieldOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ctype?: FieldOptionsCType;
        packed?: boolean;
        jstype?: FieldOptionsJSType;
        lazy?: boolean;
        unverifiedLazy?: boolean;
        deprecated?: boolean;
        weak?: boolean;
        debugRedact?: boolean;
        retention?: FieldOptionsOptionRetention;
        target?: FieldOptionsOptionTargetType;
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ctype" in data && data.ctype != undefined) {
                this.ctype = data.ctype;
            }
            if ("packed" in data && data.packed != undefined) {
                this.packed = data.packed;
            }
            if ("jstype" in data && data.jstype != undefined) {
                this.jstype = data.jstype;
            }
            if ("lazy" in data && data.lazy != undefined) {
                this.lazy = data.lazy;
            }
            if ("unverifiedLazy" in data && data.unverifiedLazy != undefined) {
                this.unverifiedLazy = data.unverifiedLazy;
            }
            if ("deprecated" in data && data.deprecated != undefined) {
                this.deprecated = data.deprecated;
            }
            if ("weak" in data && data.weak != undefined) {
                this.weak = data.weak;
            }
            if ("debugRedact" in data && data.debugRedact != undefined) {
                this.debugRedact = data.debugRedact;
            }
            if ("retention" in data && data.retention != undefined) {
                this.retention = data.retention;
            }
            if ("target" in data && data.target != undefined) {
                this.target = data.target;
            }
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get ctype() {
        return pb_1.Message.getFieldWithDefault(this, 1, FieldOptionsCType.STRING) as FieldOptionsCType;
    }
    set ctype(value: FieldOptionsCType) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasCtype() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get packed() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set packed(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasPacked() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get jstype() {
        return pb_1.Message.getFieldWithDefault(this, 6, FieldOptionsJSType.JS_NORMAL) as FieldOptionsJSType;
    }
    set jstype(value: FieldOptionsJSType) {
        pb_1.Message.setField(this, 6, value);
    }
    get hasJstype() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get lazy() {
        return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
    }
    set lazy(value: boolean) {
        pb_1.Message.setField(this, 5, value);
    }
    get hasLazy() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get unverifiedLazy() {
        return pb_1.Message.getFieldWithDefault(this, 15, false) as boolean;
    }
    set unverifiedLazy(value: boolean) {
        pb_1.Message.setField(this, 15, value);
    }
    get hasUnverifiedLazy() {
        return pb_1.Message.getField(this, 15) != null;
    }
    get deprecated() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set deprecated(value: boolean) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasDeprecated() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get weak() {
        return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
    }
    set weak(value: boolean) {
        pb_1.Message.setField(this, 10, value);
    }
    get hasWeak() {
        return pb_1.Message.getField(this, 10) != null;
    }
    get debugRedact() {
        return pb_1.Message.getFieldWithDefault(this, 16, false) as boolean;
    }
    set debugRedact(value: boolean) {
        pb_1.Message.setField(this, 16, value);
    }
    get hasDebugRedact() {
        return pb_1.Message.getField(this, 16) != null;
    }
    get retention() {
        return pb_1.Message.getFieldWithDefault(this, 17, FieldOptionsOptionRetention.RETENTION_UNKNOWN) as FieldOptionsOptionRetention;
    }
    set retention(value: FieldOptionsOptionRetention) {
        pb_1.Message.setField(this, 17, value);
    }
    get hasRetention() {
        return pb_1.Message.getField(this, 17) != null;
    }
    get target() {
        return pb_1.Message.getFieldWithDefault(this, 18, FieldOptionsOptionTargetType.TARGET_TYPE_UNKNOWN) as FieldOptionsOptionTargetType;
    }
    set target(value: FieldOptionsOptionTargetType) {
        pb_1.Message.setField(this, 18, value);
    }
    get hasTarget() {
        return pb_1.Message.getField(this, 18) != null;
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        ctype?: FieldOptionsCType;
        packed?: boolean;
        jstype?: FieldOptionsJSType;
        lazy?: boolean;
        unverifiedLazy?: boolean;
        deprecated?: boolean;
        weak?: boolean;
        debugRedact?: boolean;
        retention?: FieldOptionsOptionRetention;
        target?: FieldOptionsOptionTargetType;
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): FieldOptions {
        const message = new FieldOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        if (data.ctype != null) {
            message.ctype = data.ctype;
        }
        if (data.packed != null) {
            message.packed = data.packed;
        }
        if (data.jstype != null) {
            message.jstype = data.jstype;
        }
        if (data.lazy != null) {
            message.lazy = data.lazy;
        }
        if (data.unverifiedLazy != null) {
            message.unverifiedLazy = data.unverifiedLazy;
        }
        if (data.deprecated != null) {
            message.deprecated = data.deprecated;
        }
        if (data.weak != null) {
            message.weak = data.weak;
        }
        if (data.debugRedact != null) {
            message.debugRedact = data.debugRedact;
        }
        if (data.retention != null) {
            message.retention = data.retention;
        }
        if (data.target != null) {
            message.target = data.target;
        }
        return message;
    }
    toObject() {
        const data: {
            ctype?: FieldOptionsCType;
            packed?: boolean;
            jstype?: FieldOptionsJSType;
            lazy?: boolean;
            unverifiedLazy?: boolean;
            deprecated?: boolean;
            weak?: boolean;
            debugRedact?: boolean;
            retention?: FieldOptionsOptionRetention;
            target?: FieldOptionsOptionTargetType;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.ctype != null) {
            data.ctype = this.ctype;
        }
        if (this.packed != null) {
            data.packed = this.packed;
        }
        if (this.jstype != null) {
            data.jstype = this.jstype;
        }
        if (this.lazy != null) {
            data.lazy = this.lazy;
        }
        if (this.unverifiedLazy != null) {
            data.unverifiedLazy = this.unverifiedLazy;
        }
        if (this.deprecated != null) {
            data.deprecated = this.deprecated;
        }
        if (this.weak != null) {
            data.weak = this.weak;
        }
        if (this.debugRedact != null) {
            data.debugRedact = this.debugRedact;
        }
        if (this.retention != null) {
            data.retention = this.retention;
        }
        if (this.target != null) {
            data.target = this.target;
        }
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasCtype)
            writer.writeEnum(1, this.ctype);
        if (this.hasPacked)
            writer.writeBool(2, this.packed);
        if (this.hasJstype)
            writer.writeEnum(6, this.jstype);
        if (this.hasLazy)
            writer.writeBool(5, this.lazy);
        if (this.hasUnverifiedLazy)
            writer.writeBool(15, this.unverifiedLazy);
        if (this.hasDeprecated)
            writer.writeBool(3, this.deprecated);
        if (this.hasWeak)
            writer.writeBool(10, this.weak);
        if (this.hasDebugRedact)
            writer.writeBool(16, this.debugRedact);
        if (this.hasRetention)
            writer.writeEnum(17, this.retention);
        if (this.hasTarget)
            writer.writeEnum(18, this.target);
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FieldOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FieldOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ctype = reader.readEnum();
                    break;
                case 2:
                    message.packed = reader.readBool();
                    break;
                case 6:
                    message.jstype = reader.readEnum();
                    break;
                case 5:
                    message.lazy = reader.readBool();
                    break;
                case 15:
                    message.unverifiedLazy = reader.readBool();
                    break;
                case 3:
                    message.deprecated = reader.readBool();
                    break;
                case 10:
                    message.weak = reader.readBool();
                    break;
                case 16:
                    message.debugRedact = reader.readBool();
                    break;
                case 17:
                    message.retention = reader.readEnum();
                    break;
                case 18:
                    message.target = reader.readEnum();
                    break;
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FieldOptions {
        return FieldOptions.deserialize(bytes);
    }
}
export enum FieldOptionsCType {
    STRING = 0,
    CORD = 1,
    STRING_PIECE = 2
}
export enum FieldOptionsJSType {
    JS_NORMAL = 0,
    JS_STRING = 1,
    JS_NUMBER = 2
}
export enum FieldOptionsOptionRetention {
    RETENTION_UNKNOWN = 0,
    RETENTION_RUNTIME = 1,
    RETENTION_SOURCE = 2
}
export enum FieldOptionsOptionTargetType {
    TARGET_TYPE_UNKNOWN = 0,
    TARGET_TYPE_FILE = 1,
    TARGET_TYPE_EXTENSION_RANGE = 2,
    TARGET_TYPE_MESSAGE = 3,
    TARGET_TYPE_FIELD = 4,
    TARGET_TYPE_ONEOF = 5,
    TARGET_TYPE_ENUM = 6,
    TARGET_TYPE_ENUM_ENTRY = 7,
    TARGET_TYPE_SERVICE = 8,
    TARGET_TYPE_METHOD = 9
}
export class OneofOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): OneofOptions {
        const message = new OneofOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        return message;
    }
    toObject() {
        const data: {
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OneofOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OneofOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OneofOptions {
        return OneofOptions.deserialize(bytes);
    }
}
export class EnumOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        allowAlias?: boolean;
        deprecated?: boolean;
        /** @deprecated*/
        deprecatedLegacyJsonFieldConflicts?: boolean;
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("allowAlias" in data && data.allowAlias != undefined) {
                this.allowAlias = data.allowAlias;
            }
            if ("deprecated" in data && data.deprecated != undefined) {
                this.deprecated = data.deprecated;
            }
            if ("deprecatedLegacyJsonFieldConflicts" in data && data.deprecatedLegacyJsonFieldConflicts != undefined) {
                this.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
            }
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get allowAlias() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set allowAlias(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasAllowAlias() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get deprecated() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set deprecated(value: boolean) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasDeprecated() {
        return pb_1.Message.getField(this, 3) != null;
    }
    /** @deprecated*/
    get deprecatedLegacyJsonFieldConflicts() {
        return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
    }
    /** @deprecated*/
    set deprecatedLegacyJsonFieldConflicts(value: boolean) {
        pb_1.Message.setField(this, 6, value);
    }
    /** @deprecated*/
    get hasDeprecatedLegacyJsonFieldConflicts() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        allowAlias?: boolean;
        deprecated?: boolean;
        deprecatedLegacyJsonFieldConflicts?: boolean;
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): EnumOptions {
        const message = new EnumOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        if (data.allowAlias != null) {
            message.allowAlias = data.allowAlias;
        }
        if (data.deprecated != null) {
            message.deprecated = data.deprecated;
        }
        if (data.deprecatedLegacyJsonFieldConflicts != null) {
            message.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
        }
        return message;
    }
    toObject() {
        const data: {
            allowAlias?: boolean;
            deprecated?: boolean;
            deprecatedLegacyJsonFieldConflicts?: boolean;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.allowAlias != null) {
            data.allowAlias = this.allowAlias;
        }
        if (this.deprecated != null) {
            data.deprecated = this.deprecated;
        }
        if (this.deprecatedLegacyJsonFieldConflicts != null) {
            data.deprecatedLegacyJsonFieldConflicts = this.deprecatedLegacyJsonFieldConflicts;
        }
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasAllowAlias)
            writer.writeBool(2, this.allowAlias);
        if (this.hasDeprecated)
            writer.writeBool(3, this.deprecated);
        if (this.hasDeprecatedLegacyJsonFieldConflicts)
            writer.writeBool(6, this.deprecatedLegacyJsonFieldConflicts);
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 2:
                    message.allowAlias = reader.readBool();
                    break;
                case 3:
                    message.deprecated = reader.readBool();
                    break;
                case 6:
                    message.deprecatedLegacyJsonFieldConflicts = reader.readBool();
                    break;
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EnumOptions {
        return EnumOptions.deserialize(bytes);
    }
}
export class EnumValueOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        deprecated?: boolean;
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("deprecated" in data && data.deprecated != undefined) {
                this.deprecated = data.deprecated;
            }
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get deprecated() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set deprecated(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasDeprecated() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        deprecated?: boolean;
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): EnumValueOptions {
        const message = new EnumValueOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        if (data.deprecated != null) {
            message.deprecated = data.deprecated;
        }
        return message;
    }
    toObject() {
        const data: {
            deprecated?: boolean;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.deprecated != null) {
            data.deprecated = this.deprecated;
        }
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasDeprecated)
            writer.writeBool(1, this.deprecated);
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumValueOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumValueOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.deprecated = reader.readBool();
                    break;
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EnumValueOptions {
        return EnumValueOptions.deserialize(bytes);
    }
}
export class ServiceOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        deprecated?: boolean;
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("deprecated" in data && data.deprecated != undefined) {
                this.deprecated = data.deprecated;
            }
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get deprecated() {
        return pb_1.Message.getFieldWithDefault(this, 33, false) as boolean;
    }
    set deprecated(value: boolean) {
        pb_1.Message.setField(this, 33, value);
    }
    get hasDeprecated() {
        return pb_1.Message.getField(this, 33) != null;
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        deprecated?: boolean;
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): ServiceOptions {
        const message = new ServiceOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        if (data.deprecated != null) {
            message.deprecated = data.deprecated;
        }
        return message;
    }
    toObject() {
        const data: {
            deprecated?: boolean;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.deprecated != null) {
            data.deprecated = this.deprecated;
        }
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasDeprecated)
            writer.writeBool(33, this.deprecated);
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ServiceOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ServiceOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 33:
                    message.deprecated = reader.readBool();
                    break;
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ServiceOptions {
        return ServiceOptions.deserialize(bytes);
    }
}
export class MethodOptions extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        deprecated?: boolean;
        idempotencyLevel?: MethodOptionsIdempotencyLevel;
        uninterpretedOption: UninterpretedOption[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("deprecated" in data && data.deprecated != undefined) {
                this.deprecated = data.deprecated;
            }
            if ("idempotencyLevel" in data && data.idempotencyLevel != undefined) {
                this.idempotencyLevel = data.idempotencyLevel;
            }
            this.uninterpretedOption = data.uninterpretedOption;
        }
    }
    get deprecated() {
        return pb_1.Message.getFieldWithDefault(this, 33, false) as boolean;
    }
    set deprecated(value: boolean) {
        pb_1.Message.setField(this, 33, value);
    }
    get hasDeprecated() {
        return pb_1.Message.getField(this, 33) != null;
    }
    get idempotencyLevel() {
        return pb_1.Message.getFieldWithDefault(this, 34, MethodOptionsIdempotencyLevel.IDEMPOTENCY_UNKNOWN) as MethodOptionsIdempotencyLevel;
    }
    set idempotencyLevel(value: MethodOptionsIdempotencyLevel) {
        pb_1.Message.setField(this, 34, value);
    }
    get hasIdempotencyLevel() {
        return pb_1.Message.getField(this, 34) != null;
    }
    get uninterpretedOption() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
    }
    set uninterpretedOption(value: UninterpretedOption[]) {
        pb_1.Message.setRepeatedWrapperField(this, 999, value);
    }
    static fromObject(data: {
        deprecated?: boolean;
        idempotencyLevel?: MethodOptionsIdempotencyLevel;
        uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
    }): MethodOptions {
        const message = new MethodOptions({
            uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
        });
        if (data.deprecated != null) {
            message.deprecated = data.deprecated;
        }
        if (data.idempotencyLevel != null) {
            message.idempotencyLevel = data.idempotencyLevel;
        }
        return message;
    }
    toObject() {
        const data: {
            deprecated?: boolean;
            idempotencyLevel?: MethodOptionsIdempotencyLevel;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        } = {};
        if (this.deprecated != null) {
            data.deprecated = this.deprecated;
        }
        if (this.idempotencyLevel != null) {
            data.idempotencyLevel = this.idempotencyLevel;
        }
        if (this.uninterpretedOption != null) {
            data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasDeprecated)
            writer.writeBool(33, this.deprecated);
        if (this.hasIdempotencyLevel)
            writer.writeEnum(34, this.idempotencyLevel);
        if (this.uninterpretedOption.length)
            writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MethodOptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MethodOptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 33:
                    message.deprecated = reader.readBool();
                    break;
                case 34:
                    message.idempotencyLevel = reader.readEnum();
                    break;
                case 999:
                    reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MethodOptions {
        return MethodOptions.deserialize(bytes);
    }
}
export enum MethodOptionsIdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0,
    NO_SIDE_EFFECTS = 1,
    IDEMPOTENT = 2
}
export class UninterpretedOption extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name: UninterpretedOptionNamePart[];
        identifierValue?: string;
        positiveIntValue?: number;
        negativeIntValue?: number;
        doubleValue?: number;
        stringValue?: Uint8Array;
        aggregateValue?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.name = data.name;
            if ("identifierValue" in data && data.identifierValue != undefined) {
                this.identifierValue = data.identifierValue;
            }
            if ("positiveIntValue" in data && data.positiveIntValue != undefined) {
                this.positiveIntValue = data.positiveIntValue;
            }
            if ("negativeIntValue" in data && data.negativeIntValue != undefined) {
                this.negativeIntValue = data.negativeIntValue;
            }
            if ("doubleValue" in data && data.doubleValue != undefined) {
                this.doubleValue = data.doubleValue;
            }
            if ("stringValue" in data && data.stringValue != undefined) {
                this.stringValue = data.stringValue;
            }
            if ("aggregateValue" in data && data.aggregateValue != undefined) {
                this.aggregateValue = data.aggregateValue;
            }
        }
    }
    get name() {
        return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOptionNamePart, 2) as UninterpretedOptionNamePart[];
    }
    set name(value: UninterpretedOptionNamePart[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get identifierValue() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set identifierValue(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasIdentifierValue() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get positiveIntValue() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set positiveIntValue(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get hasPositiveIntValue() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get negativeIntValue() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set negativeIntValue(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get hasNegativeIntValue() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get doubleValue() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set doubleValue(value: number) {
        pb_1.Message.setField(this, 6, value);
    }
    get hasDoubleValue() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get stringValue() {
        return pb_1.Message.getFieldWithDefault(this, 7, new Uint8Array(0)) as Uint8Array;
    }
    set stringValue(value: Uint8Array) {
        pb_1.Message.setField(this, 7, value);
    }
    get hasStringValue() {
        return pb_1.Message.getField(this, 7) != null;
    }
    get aggregateValue() {
        return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set aggregateValue(value: string) {
        pb_1.Message.setField(this, 8, value);
    }
    get hasAggregateValue() {
        return pb_1.Message.getField(this, 8) != null;
    }
    static fromObject(data: {
        name?: ReturnType<typeof UninterpretedOptionNamePart.prototype.toObject>[];
        identifierValue?: string;
        positiveIntValue?: number;
        negativeIntValue?: number;
        doubleValue?: number;
        stringValue?: Uint8Array;
        aggregateValue?: string;
    }): UninterpretedOption {
        const message = new UninterpretedOption({
            name: data.name.map(item => UninterpretedOptionNamePart.fromObject(item))
        });
        if (data.identifierValue != null) {
            message.identifierValue = data.identifierValue;
        }
        if (data.positiveIntValue != null) {
            message.positiveIntValue = data.positiveIntValue;
        }
        if (data.negativeIntValue != null) {
            message.negativeIntValue = data.negativeIntValue;
        }
        if (data.doubleValue != null) {
            message.doubleValue = data.doubleValue;
        }
        if (data.stringValue != null) {
            message.stringValue = data.stringValue;
        }
        if (data.aggregateValue != null) {
            message.aggregateValue = data.aggregateValue;
        }
        return message;
    }
    toObject() {
        const data: {
            name?: ReturnType<typeof UninterpretedOptionNamePart.prototype.toObject>[];
            identifierValue?: string;
            positiveIntValue?: number;
            negativeIntValue?: number;
            doubleValue?: number;
            stringValue?: Uint8Array;
            aggregateValue?: string;
        } = {};
        if (this.name != null) {
            data.name = this.name.map((item: UninterpretedOptionNamePart) => item.toObject());
        }
        if (this.identifierValue != null) {
            data.identifierValue = this.identifierValue;
        }
        if (this.positiveIntValue != null) {
            data.positiveIntValue = this.positiveIntValue;
        }
        if (this.negativeIntValue != null) {
            data.negativeIntValue = this.negativeIntValue;
        }
        if (this.doubleValue != null) {
            data.doubleValue = this.doubleValue;
        }
        if (this.stringValue != null) {
            data.stringValue = this.stringValue;
        }
        if (this.aggregateValue != null) {
            data.aggregateValue = this.aggregateValue;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeRepeatedMessage(2, this.name, (item: UninterpretedOptionNamePart) => item.serialize(writer));
        if (this.hasIdentifierValue && this.identifierValue.length)
            writer.writeString(3, this.identifierValue);
        if (this.hasPositiveIntValue)
            writer.writeUint64(4, this.positiveIntValue);
        if (this.hasNegativeIntValue)
            writer.writeInt64(5, this.negativeIntValue);
        if (this.hasDoubleValue)
            writer.writeDouble(6, this.doubleValue);
        if (this.hasStringValue && this.stringValue.length)
            writer.writeBytes(7, this.stringValue);
        if (this.hasAggregateValue && this.aggregateValue.length)
            writer.writeString(8, this.aggregateValue);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UninterpretedOption {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UninterpretedOption();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 2:
                    reader.readMessage(message.name, () => pb_1.Message.addToRepeatedWrapperField(message, 2, UninterpretedOptionNamePart.deserialize(reader), UninterpretedOptionNamePart));
                    break;
                case 3:
                    message.identifierValue = reader.readString();
                    break;
                case 4:
                    message.positiveIntValue = reader.readUint64();
                    break;
                case 5:
                    message.negativeIntValue = reader.readInt64();
                    break;
                case 6:
                    message.doubleValue = reader.readDouble();
                    break;
                case 7:
                    message.stringValue = reader.readBytes();
                    break;
                case 8:
                    message.aggregateValue = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UninterpretedOption {
        return UninterpretedOption.deserialize(bytes);
    }
}
export class UninterpretedOptionNamePart extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        namePart: string;
        isExtension: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.namePart = data.namePart;
            this.isExtension = data.isExtension;
        }
    }
    get namePart() {
        return pb_1.Message.getField(this, 1) as string;
    }
    set namePart(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasNamePart() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get isExtension() {
        return pb_1.Message.getField(this, 2) as boolean;
    }
    set isExtension(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasIsExtension() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        namePart?: string;
        isExtension?: boolean;
    }): UninterpretedOptionNamePart {
        const message = new UninterpretedOptionNamePart({
            namePart: data.namePart,
            isExtension: data.isExtension
        });
        return message;
    }
    toObject() {
        const data: {
            namePart?: string;
            isExtension?: boolean;
        } = {};
        if (this.namePart != null) {
            data.namePart = this.namePart;
        }
        if (this.isExtension != null) {
            data.isExtension = this.isExtension;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasNamePart && this.namePart.length)
            writer.writeString(1, this.namePart);
        if (this.hasIsExtension)
            writer.writeBool(2, this.isExtension);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UninterpretedOptionNamePart {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UninterpretedOptionNamePart();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.namePart = reader.readString();
                    break;
                case 2:
                    message.isExtension = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UninterpretedOptionNamePart {
        return UninterpretedOptionNamePart.deserialize(bytes);
    }
}
export class SourceCodeInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        location: SourceCodeInfoLocation[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.location = data.location;
        }
    }
    get location() {
        return pb_1.Message.getRepeatedWrapperField(this, SourceCodeInfoLocation, 1) as SourceCodeInfoLocation[];
    }
    set location(value: SourceCodeInfoLocation[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        location?: ReturnType<typeof SourceCodeInfoLocation.prototype.toObject>[];
    }): SourceCodeInfo {
        const message = new SourceCodeInfo({
            location: data.location.map(item => SourceCodeInfoLocation.fromObject(item))
        });
        return message;
    }
    toObject() {
        const data: {
            location?: ReturnType<typeof SourceCodeInfoLocation.prototype.toObject>[];
        } = {};
        if (this.location != null) {
            data.location = this.location.map((item: SourceCodeInfoLocation) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.location.length)
            writer.writeRepeatedMessage(1, this.location, (item: SourceCodeInfoLocation) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SourceCodeInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SourceCodeInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.location, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SourceCodeInfoLocation.deserialize(reader), SourceCodeInfoLocation));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SourceCodeInfo {
        return SourceCodeInfo.deserialize(bytes);
    }
}
export class SourceCodeInfoLocation extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        path: number[];
        span: number[];
        leadingComments?: string;
        trailingComments?: string;
        leadingDetachedComments: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 6], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.path = data.path;
            this.span = data.span;
            if ("leadingComments" in data && data.leadingComments != undefined) {
                this.leadingComments = data.leadingComments;
            }
            if ("trailingComments" in data && data.trailingComments != undefined) {
                this.trailingComments = data.trailingComments;
            }
            this.leadingDetachedComments = data.leadingDetachedComments;
        }
    }
    get path() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
    }
    set path(value: number[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get span() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as number[];
    }
    set span(value: number[]) {
        pb_1.Message.setField(this, 2, value);
    }
    get leadingComments() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set leadingComments(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasLeadingComments() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get trailingComments() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set trailingComments(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get hasTrailingComments() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get leadingDetachedComments() {
        return pb_1.Message.getFieldWithDefault(this, 6, []) as string[];
    }
    set leadingDetachedComments(value: string[]) {
        pb_1.Message.setField(this, 6, value);
    }
    static fromObject(data: {
        path: number[];
        span: number[];
        leadingComments?: string;
        trailingComments?: string;
        leadingDetachedComments: string[];
    }): SourceCodeInfoLocation {
        const message = new SourceCodeInfoLocation({
            path: data.path,
            span: data.span,
            leadingDetachedComments: data.leadingDetachedComments
        });
        if (data.leadingComments != null) {
            message.leadingComments = data.leadingComments;
        }
        if (data.trailingComments != null) {
            message.trailingComments = data.trailingComments;
        }
        return message;
    }
    toObject() {
        const data: {
            path: number[];
            span: number[];
            leadingComments?: string;
            trailingComments?: string;
            leadingDetachedComments: string[];
        } = {
            path: this.path,
            span: this.span,
            leadingDetachedComments: this.leadingDetachedComments
        };
        if (this.leadingComments != null) {
            data.leadingComments = this.leadingComments;
        }
        if (this.trailingComments != null) {
            data.trailingComments = this.trailingComments;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.path.length)
            writer.writePackedInt32(1, this.path);
        if (this.span.length)
            writer.writePackedInt32(2, this.span);
        if (this.hasLeadingComments && this.leadingComments.length)
            writer.writeString(3, this.leadingComments);
        if (this.hasTrailingComments && this.trailingComments.length)
            writer.writeString(4, this.trailingComments);
        if (this.leadingDetachedComments.length)
            writer.writeRepeatedString(6, this.leadingDetachedComments);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SourceCodeInfoLocation {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SourceCodeInfoLocation();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.path = reader.readPackedInt32();
                    break;
                case 2:
                    message.span = reader.readPackedInt32();
                    break;
                case 3:
                    message.leadingComments = reader.readString();
                    break;
                case 4:
                    message.trailingComments = reader.readString();
                    break;
                case 6:
                    pb_1.Message.addToRepeatedField(message, 6, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SourceCodeInfoLocation {
        return SourceCodeInfoLocation.deserialize(bytes);
    }
}
export class GeneratedCodeInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        annotation: GeneratedCodeInfoAnnotation[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.annotation = data.annotation;
        }
    }
    get annotation() {
        return pb_1.Message.getRepeatedWrapperField(this, GeneratedCodeInfoAnnotation, 1) as GeneratedCodeInfoAnnotation[];
    }
    set annotation(value: GeneratedCodeInfoAnnotation[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        annotation?: ReturnType<typeof GeneratedCodeInfoAnnotation.prototype.toObject>[];
    }): GeneratedCodeInfo {
        const message = new GeneratedCodeInfo({
            annotation: data.annotation.map(item => GeneratedCodeInfoAnnotation.fromObject(item))
        });
        return message;
    }
    toObject() {
        const data: {
            annotation?: ReturnType<typeof GeneratedCodeInfoAnnotation.prototype.toObject>[];
        } = {};
        if (this.annotation != null) {
            data.annotation = this.annotation.map((item: GeneratedCodeInfoAnnotation) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.annotation.length)
            writer.writeRepeatedMessage(1, this.annotation, (item: GeneratedCodeInfoAnnotation) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeneratedCodeInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeneratedCodeInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.annotation, () => pb_1.Message.addToRepeatedWrapperField(message, 1, GeneratedCodeInfoAnnotation.deserialize(reader), GeneratedCodeInfoAnnotation));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GeneratedCodeInfo {
        return GeneratedCodeInfo.deserialize(bytes);
    }
}
export class GeneratedCodeInfoAnnotation extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        path: number[];
        sourceFile?: string;
        begin?: number;
        end?: number;
        semantic?: GeneratedCodeInfoAnnotationSemantic;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.path = data.path;
            if ("sourceFile" in data && data.sourceFile != undefined) {
                this.sourceFile = data.sourceFile;
            }
            if ("begin" in data && data.begin != undefined) {
                this.begin = data.begin;
            }
            if ("end" in data && data.end != undefined) {
                this.end = data.end;
            }
            if ("semantic" in data && data.semantic != undefined) {
                this.semantic = data.semantic;
            }
        }
    }
    get path() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
    }
    set path(value: number[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get sourceFile() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set sourceFile(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasSourceFile() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get begin() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set begin(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasBegin() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get end() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set end(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get hasEnd() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get semantic() {
        return pb_1.Message.getFieldWithDefault(this, 5, GeneratedCodeInfoAnnotationSemantic.NONE) as GeneratedCodeInfoAnnotationSemantic;
    }
    set semantic(value: GeneratedCodeInfoAnnotationSemantic) {
        pb_1.Message.setField(this, 5, value);
    }
    get hasSemantic() {
        return pb_1.Message.getField(this, 5) != null;
    }
    static fromObject(data: {
        path: number[];
        sourceFile?: string;
        begin?: number;
        end?: number;
        semantic?: GeneratedCodeInfoAnnotationSemantic;
    }): GeneratedCodeInfoAnnotation {
        const message = new GeneratedCodeInfoAnnotation({
            path: data.path
        });
        if (data.sourceFile != null) {
            message.sourceFile = data.sourceFile;
        }
        if (data.begin != null) {
            message.begin = data.begin;
        }
        if (data.end != null) {
            message.end = data.end;
        }
        if (data.semantic != null) {
            message.semantic = data.semantic;
        }
        return message;
    }
    toObject() {
        const data: {
            path: number[];
            sourceFile?: string;
            begin?: number;
            end?: number;
            semantic?: GeneratedCodeInfoAnnotationSemantic;
        } = {
            path: this.path
        };
        if (this.sourceFile != null) {
            data.sourceFile = this.sourceFile;
        }
        if (this.begin != null) {
            data.begin = this.begin;
        }
        if (this.end != null) {
            data.end = this.end;
        }
        if (this.semantic != null) {
            data.semantic = this.semantic;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.path.length)
            writer.writePackedInt32(1, this.path);
        if (this.hasSourceFile && this.sourceFile.length)
            writer.writeString(2, this.sourceFile);
        if (this.hasBegin)
            writer.writeInt32(3, this.begin);
        if (this.hasEnd)
            writer.writeInt32(4, this.end);
        if (this.hasSemantic)
            writer.writeEnum(5, this.semantic);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeneratedCodeInfoAnnotation {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeneratedCodeInfoAnnotation();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.path = reader.readPackedInt32();
                    break;
                case 2:
                    message.sourceFile = reader.readString();
                    break;
                case 3:
                    message.begin = reader.readInt32();
                    break;
                case 4:
                    message.end = reader.readInt32();
                    break;
                case 5:
                    message.semantic = reader.readEnum();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GeneratedCodeInfoAnnotation {
        return GeneratedCodeInfoAnnotation.deserialize(bytes);
    }
}
export enum GeneratedCodeInfoAnnotationSemantic {
    NONE = 0,
    SET = 1,
    ALIAS = 2
}
