// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file stub/data-source.proto (package stub, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Resource } from "../model/resource_pb";
import { DataSource, DataSourceCatalog } from "../model/data-source_pb";

/**
 * @generated from message stub.PrepareResourceFromEntityRequest
 */
export class PrepareResourceFromEntityRequest extends Message<PrepareResourceFromEntityRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * data source id, required, It is for specifying that which database the operation will be performed
   *
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * catalog is optional, if not provided, default catalog will be used, catalog is like schema in database
   *
   * @generated from field: string catalog = 3;
   */
  catalog = "";

  /**
   * entity is required, it is like table in database, collection on mongodb, etc.
   *
   * @generated from field: string entity = 4;
   */
  entity = "";

  constructor(data?: PartialMessage<PrepareResourceFromEntityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.PrepareResourceFromEntityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "catalog", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "entity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrepareResourceFromEntityRequest {
    return new PrepareResourceFromEntityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrepareResourceFromEntityRequest {
    return new PrepareResourceFromEntityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrepareResourceFromEntityRequest {
    return new PrepareResourceFromEntityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PrepareResourceFromEntityRequest | PlainMessage<PrepareResourceFromEntityRequest> | undefined, b: PrepareResourceFromEntityRequest | PlainMessage<PrepareResourceFromEntityRequest> | undefined): boolean {
    return proto3.util.equals(PrepareResourceFromEntityRequest, a, b);
  }
}

/**
 * @generated from message stub.PrepareResourceFromEntityResponse
 */
export class PrepareResourceFromEntityResponse extends Message<PrepareResourceFromEntityResponse> {
  /**
   * @generated from field: model.Resource resource = 1;
   */
  resource?: Resource;

  constructor(data?: PartialMessage<PrepareResourceFromEntityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.PrepareResourceFromEntityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: Resource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrepareResourceFromEntityResponse {
    return new PrepareResourceFromEntityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrepareResourceFromEntityResponse {
    return new PrepareResourceFromEntityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrepareResourceFromEntityResponse {
    return new PrepareResourceFromEntityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PrepareResourceFromEntityResponse | PlainMessage<PrepareResourceFromEntityResponse> | undefined, b: PrepareResourceFromEntityResponse | PlainMessage<PrepareResourceFromEntityResponse> | undefined): boolean {
    return proto3.util.equals(PrepareResourceFromEntityResponse, a, b);
  }
}

/**
 * @generated from message stub.StatusRequest
 */
export class StatusRequest extends Message<StatusRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<StatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.StatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusRequest {
    return new StatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StatusRequest | PlainMessage<StatusRequest> | undefined, b: StatusRequest | PlainMessage<StatusRequest> | undefined): boolean {
    return proto3.util.equals(StatusRequest, a, b);
  }
}

/**
 * @generated from message stub.StatusResponse
 */
export class StatusResponse extends Message<StatusResponse> {
  /**
   * @generated from field: bool connectionAlreadyInitiated = 1;
   */
  connectionAlreadyInitiated = false;

  /**
   * @generated from field: bool testConnection = 2;
   */
  testConnection = false;

  constructor(data?: PartialMessage<StatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.StatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connectionAlreadyInitiated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "testConnection", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusResponse {
    return new StatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusResponse {
    return new StatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusResponse {
    return new StatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StatusResponse | PlainMessage<StatusResponse> | undefined, b: StatusResponse | PlainMessage<StatusResponse> | undefined): boolean {
    return proto3.util.equals(StatusResponse, a, b);
  }
}

/**
 * @generated from message stub.ListEntitiesRequest
 */
export class ListEntitiesRequest extends Message<ListEntitiesRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<ListEntitiesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.ListEntitiesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEntitiesRequest {
    return new ListEntitiesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEntitiesRequest {
    return new ListEntitiesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEntitiesRequest {
    return new ListEntitiesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListEntitiesRequest | PlainMessage<ListEntitiesRequest> | undefined, b: ListEntitiesRequest | PlainMessage<ListEntitiesRequest> | undefined): boolean {
    return proto3.util.equals(ListEntitiesRequest, a, b);
  }
}

/**
 * @generated from message stub.ListEntitiesResponse
 */
export class ListEntitiesResponse extends Message<ListEntitiesResponse> {
  /**
   * @generated from field: repeated model.DataSourceCatalog catalogs = 1;
   */
  catalogs: DataSourceCatalog[] = [];

  constructor(data?: PartialMessage<ListEntitiesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.ListEntitiesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "catalogs", kind: "message", T: DataSourceCatalog, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEntitiesResponse {
    return new ListEntitiesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEntitiesResponse {
    return new ListEntitiesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEntitiesResponse {
    return new ListEntitiesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListEntitiesResponse | PlainMessage<ListEntitiesResponse> | undefined, b: ListEntitiesResponse | PlainMessage<ListEntitiesResponse> | undefined): boolean {
    return proto3.util.equals(ListEntitiesResponse, a, b);
  }
}

/**
 * @generated from message stub.ListDataSourceRequest
 */
export class ListDataSourceRequest extends Message<ListDataSourceRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<ListDataSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.ListDataSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDataSourceRequest {
    return new ListDataSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDataSourceRequest {
    return new ListDataSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDataSourceRequest {
    return new ListDataSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDataSourceRequest | PlainMessage<ListDataSourceRequest> | undefined, b: ListDataSourceRequest | PlainMessage<ListDataSourceRequest> | undefined): boolean {
    return proto3.util.equals(ListDataSourceRequest, a, b);
  }
}

/**
 * @generated from message stub.ListDataSourceResponse
 */
export class ListDataSourceResponse extends Message<ListDataSourceResponse> {
  /**
   * @generated from field: repeated model.DataSource content = 2;
   */
  content: DataSource[] = [];

  constructor(data?: PartialMessage<ListDataSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.ListDataSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "content", kind: "message", T: DataSource, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDataSourceResponse {
    return new ListDataSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDataSourceResponse {
    return new ListDataSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDataSourceResponse {
    return new ListDataSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDataSourceResponse | PlainMessage<ListDataSourceResponse> | undefined, b: ListDataSourceResponse | PlainMessage<ListDataSourceResponse> | undefined): boolean {
    return proto3.util.equals(ListDataSourceResponse, a, b);
  }
}

/**
 * @generated from message stub.CreateDataSourceRequest
 */
export class CreateDataSourceRequest extends Message<CreateDataSourceRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * @generated from field: repeated model.DataSource dataSources = 2;
   */
  dataSources: DataSource[] = [];

  constructor(data?: PartialMessage<CreateDataSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.CreateDataSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dataSources", kind: "message", T: DataSource, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDataSourceRequest {
    return new CreateDataSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDataSourceRequest {
    return new CreateDataSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDataSourceRequest {
    return new CreateDataSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDataSourceRequest | PlainMessage<CreateDataSourceRequest> | undefined, b: CreateDataSourceRequest | PlainMessage<CreateDataSourceRequest> | undefined): boolean {
    return proto3.util.equals(CreateDataSourceRequest, a, b);
  }
}

/**
 * @generated from message stub.CreateDataSourceResponse
 */
export class CreateDataSourceResponse extends Message<CreateDataSourceResponse> {
  /**
   * @generated from field: repeated model.DataSource dataSources = 1;
   */
  dataSources: DataSource[] = [];

  constructor(data?: PartialMessage<CreateDataSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.CreateDataSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataSources", kind: "message", T: DataSource, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDataSourceResponse {
    return new CreateDataSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDataSourceResponse {
    return new CreateDataSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDataSourceResponse {
    return new CreateDataSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDataSourceResponse | PlainMessage<CreateDataSourceResponse> | undefined, b: CreateDataSourceResponse | PlainMessage<CreateDataSourceResponse> | undefined): boolean {
    return proto3.util.equals(CreateDataSourceResponse, a, b);
  }
}

/**
 * @generated from message stub.UpdateDataSourceRequest
 */
export class UpdateDataSourceRequest extends Message<UpdateDataSourceRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * @generated from field: repeated model.DataSource dataSources = 2;
   */
  dataSources: DataSource[] = [];

  constructor(data?: PartialMessage<UpdateDataSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.UpdateDataSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dataSources", kind: "message", T: DataSource, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDataSourceRequest {
    return new UpdateDataSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDataSourceRequest {
    return new UpdateDataSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDataSourceRequest {
    return new UpdateDataSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDataSourceRequest | PlainMessage<UpdateDataSourceRequest> | undefined, b: UpdateDataSourceRequest | PlainMessage<UpdateDataSourceRequest> | undefined): boolean {
    return proto3.util.equals(UpdateDataSourceRequest, a, b);
  }
}

/**
 * @generated from message stub.UpdateDataSourceResponse
 */
export class UpdateDataSourceResponse extends Message<UpdateDataSourceResponse> {
  /**
   * @generated from field: repeated model.DataSource dataSources = 1;
   */
  dataSources: DataSource[] = [];

  constructor(data?: PartialMessage<UpdateDataSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.UpdateDataSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataSources", kind: "message", T: DataSource, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDataSourceResponse {
    return new UpdateDataSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDataSourceResponse {
    return new UpdateDataSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDataSourceResponse {
    return new UpdateDataSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDataSourceResponse | PlainMessage<UpdateDataSourceResponse> | undefined, b: UpdateDataSourceResponse | PlainMessage<UpdateDataSourceResponse> | undefined): boolean {
    return proto3.util.equals(UpdateDataSourceResponse, a, b);
  }
}

/**
 * @generated from message stub.DeleteDataSourceRequest
 */
export class DeleteDataSourceRequest extends Message<DeleteDataSourceRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * @generated from field: repeated string ids = 2;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<DeleteDataSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.DeleteDataSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDataSourceRequest {
    return new DeleteDataSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDataSourceRequest {
    return new DeleteDataSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDataSourceRequest {
    return new DeleteDataSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDataSourceRequest | PlainMessage<DeleteDataSourceRequest> | undefined, b: DeleteDataSourceRequest | PlainMessage<DeleteDataSourceRequest> | undefined): boolean {
    return proto3.util.equals(DeleteDataSourceRequest, a, b);
  }
}

/**
 * @generated from message stub.DeleteDataSourceResponse
 */
export class DeleteDataSourceResponse extends Message<DeleteDataSourceResponse> {
  constructor(data?: PartialMessage<DeleteDataSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.DeleteDataSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDataSourceResponse {
    return new DeleteDataSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDataSourceResponse {
    return new DeleteDataSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDataSourceResponse {
    return new DeleteDataSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDataSourceResponse | PlainMessage<DeleteDataSourceResponse> | undefined, b: DeleteDataSourceResponse | PlainMessage<DeleteDataSourceResponse> | undefined): boolean {
    return proto3.util.equals(DeleteDataSourceResponse, a, b);
  }
}

/**
 * @generated from message stub.GetDataSourceRequest
 */
export class GetDataSourceRequest extends Message<GetDataSourceRequest> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<GetDataSourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.GetDataSourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDataSourceRequest {
    return new GetDataSourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDataSourceRequest {
    return new GetDataSourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDataSourceRequest {
    return new GetDataSourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDataSourceRequest | PlainMessage<GetDataSourceRequest> | undefined, b: GetDataSourceRequest | PlainMessage<GetDataSourceRequest> | undefined): boolean {
    return proto3.util.equals(GetDataSourceRequest, a, b);
  }
}

/**
 * @generated from message stub.GetDataSourceResponse
 */
export class GetDataSourceResponse extends Message<GetDataSourceResponse> {
  /**
   * @generated from field: model.DataSource dataSource = 1;
   */
  dataSource?: DataSource;

  constructor(data?: PartialMessage<GetDataSourceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stub.GetDataSourceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataSource", kind: "message", T: DataSource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDataSourceResponse {
    return new GetDataSourceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDataSourceResponse {
    return new GetDataSourceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDataSourceResponse {
    return new GetDataSourceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetDataSourceResponse | PlainMessage<GetDataSourceResponse> | undefined, b: GetDataSourceResponse | PlainMessage<GetDataSourceResponse> | undefined): boolean {
    return proto3.util.equals(GetDataSourceResponse, a, b);
  }
}

