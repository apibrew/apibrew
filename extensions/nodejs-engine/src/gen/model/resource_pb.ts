// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file model/resource.proto (package model, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Value } from "@bufbuild/protobuf";
import { SecurityContext } from "./security_pb";
import { AuditData } from "./audit_pb";

/**
 * @generated from enum model.Order
 */
export enum Order {
  /**
   * @generated from enum value: ORDER_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: ORDER_ASC = 1;
   */
  ASC = 1,

  /**
   * @generated from enum value: ORDER_DESC = 2;
   */
  DESC = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Order)
proto3.util.setEnumType(Order, "model.Order", [
  { no: 0, name: "ORDER_UNKNOWN" },
  { no: 1, name: "ORDER_ASC" },
  { no: 2, name: "ORDER_DESC" },
]);

/**
 * @generated from enum model.ResourceIndexType
 */
export enum ResourceIndexType {
  /**
   * @generated from enum value: BTREE = 0;
   */
  BTREE = 0,

  /**
   * @generated from enum value: HASH = 1;
   */
  HASH = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ResourceIndexType)
proto3.util.setEnumType(ResourceIndexType, "model.ResourceIndexType", [
  { no: 0, name: "BTREE" },
  { no: 1, name: "HASH" },
]);

/**
 *
 * Resource properties is used to describe its schema. Each resource property is corresponding to a field in a record
 * API Brew is responsible to validate data according to property types. For example, when you call create record and
 * if you send 123.45 for int64
 *
 * @generated from message model.ResourceProperty
 */
export class ResourceProperty extends Message<ResourceProperty> {
  /**
   * @generated from field: optional string id = 1;
   */
  id?: string;

  /**
   *
   * property name
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * type of property
   *
   * @generated from field: model.ResourceProperty.Type type = 3;
   */
  type = ResourceProperty_Type.BOOL;

  /**
   * type ref
   *
   * type ref, is only applicable to Struct
   *
   * @generated from field: optional string typeRef = 17;
   */
  typeRef?: string;

  /**
   * mapping is like a column name, it is binding name to entity. For abstraction purposes property name is not used while communicating to resource backend. Instead mapping is used as a key of property
   *
   * @generated from field: string mapping = 4;
   */
  mapping = "";

  /**
   * this is to mark property as required
   *
   * @generated from field: bool required = 5;
   */
  required = false;

  /**
   * this is to mark property as primary. Primary properties is like a part of primary key. Primary property(s) is used in to identify record.
   *
   * @generated from field: bool primary = 6;
   */
  primary = false;

  /**
   * length property is only valid and required for String typed properties
   *
   * @generated from field: uint32 length = 7;
   */
  length = 0;

  /**
   * @generated from field: bool unique = 8;
   */
  unique = false;

  /**
   * immutable is to mark property as immutable. If marked, updates on this field on records will be discarded
   *
   * @generated from field: bool immutable = 9;
   */
  immutable = false;

  /**
   * security context is to apply ACL to resource property
   *
   * @generated from field: optional model.SecurityContext securityContext = 10;
   */
  securityContext?: SecurityContext;

  /**
   * defaultValue is default value.
   *
   * @generated from field: optional google.protobuf.Value defaultValue = 11;
   */
  defaultValue?: Value;

  /**
   * exampleValue is example value. It is an informative column
   *
   * @generated from field: optional google.protobuf.Value exampleValue = 12;
   */
  exampleValue?: Value;

  /**
   * enumValues is used if property type is an enum
   *
   * @generated from field: repeated string enumValues = 13;
   */
  enumValues: string[] = [];

  /**
   * reference property is only valid and required for Reference types.
   *
   * @generated from field: optional model.Reference reference = 14;
   */
  reference?: Reference;

  /**
   * list of properties of struct. This properties will be used by records of resource. Properties is columns on sql databases. For schemaless data structures properties is only managed by API Brew itself
   *
   * @generated from field: repeated model.ResourceProperty properties = 15;
   */
  properties: ResourceProperty[] = [];

  /**
   * item is used for complex types(list, map). For list, subType is element type. For map, it is value type(key type is always string)
   *
   * @generated from field: optional model.ResourceProperty item = 16;
   */
  item?: ResourceProperty;

  /**
   * It is an informative column
   *
   * @generated from field: optional string title = 18;
   */
  title?: string;

  /**
   * It is an informative column
   *
   * @generated from field: optional string description = 19;
   */
  description?: string;

  /**
   * @generated from field: map<string, string> annotations = 103;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ResourceProperty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.ResourceProperty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(ResourceProperty_Type) },
    { no: 17, name: "typeRef", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "mapping", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "primary", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "unique", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "immutable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "securityContext", kind: "message", T: SecurityContext, opt: true },
    { no: 11, name: "defaultValue", kind: "message", T: Value, opt: true },
    { no: 12, name: "exampleValue", kind: "message", T: Value, opt: true },
    { no: 13, name: "enumValues", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "reference", kind: "message", T: Reference, opt: true },
    { no: 15, name: "properties", kind: "message", T: ResourceProperty, repeated: true },
    { no: 16, name: "item", kind: "message", T: ResourceProperty, opt: true },
    { no: 18, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 19, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 103, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceProperty {
    return new ResourceProperty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceProperty {
    return new ResourceProperty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceProperty {
    return new ResourceProperty().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceProperty | PlainMessage<ResourceProperty> | undefined, b: ResourceProperty | PlainMessage<ResourceProperty> | undefined): boolean {
    return proto3.util.equals(ResourceProperty, a, b);
  }
}

/**
 * @generated from enum model.ResourceProperty.Type
 */
export enum ResourceProperty_Type {
  /**
   * @generated from enum value: BOOL = 0;
   */
  BOOL = 0,

  /**
   * @generated from enum value: STRING = 1;
   */
  STRING = 1,

  /**
   * @generated from enum value: FLOAT32 = 2;
   */
  FLOAT32 = 2,

  /**
   * @generated from enum value: FLOAT64 = 3;
   */
  FLOAT64 = 3,

  /**
   * @generated from enum value: INT32 = 4;
   */
  INT32 = 4,

  /**
   * @generated from enum value: INT64 = 5;
   */
  INT64 = 5,

  /**
   * @generated from enum value: BYTES = 6;
   */
  BYTES = 6,

  /**
   * @generated from enum value: UUID = 8;
   */
  UUID = 8,

  /**
   * @generated from enum value: DATE = 9;
   */
  DATE = 9,

  /**
   * @generated from enum value: TIME = 10;
   */
  TIME = 10,

  /**
   * @generated from enum value: TIMESTAMP = 11;
   */
  TIMESTAMP = 11,

  /**
   * @generated from enum value: OBJECT = 12;
   */
  OBJECT = 12,

  /**
   * @generated from enum value: MAP = 13;
   */
  MAP = 13,

  /**
   * @generated from enum value: LIST = 14;
   */
  LIST = 14,

  /**
   * @generated from enum value: REFERENCE = 15;
   */
  REFERENCE = 15,

  /**
   * @generated from enum value: ENUM = 16;
   */
  ENUM = 16,

  /**
   * @generated from enum value: STRUCT = 17;
   */
  STRUCT = 17,
}
// Retrieve enum metadata with: proto3.getEnumType(ResourceProperty_Type)
proto3.util.setEnumType(ResourceProperty_Type, "model.ResourceProperty.Type", [
  { no: 0, name: "BOOL" },
  { no: 1, name: "STRING" },
  { no: 2, name: "FLOAT32" },
  { no: 3, name: "FLOAT64" },
  { no: 4, name: "INT32" },
  { no: 5, name: "INT64" },
  { no: 6, name: "BYTES" },
  { no: 8, name: "UUID" },
  { no: 9, name: "DATE" },
  { no: 10, name: "TIME" },
  { no: 11, name: "TIMESTAMP" },
  { no: 12, name: "OBJECT" },
  { no: 13, name: "MAP" },
  { no: 14, name: "LIST" },
  { no: 15, name: "REFERENCE" },
  { no: 16, name: "ENUM" },
  { no: 17, name: "STRUCT" },
]);

/**
 * @generated from message model.Reference
 */
export class Reference extends Message<Reference> {
  /**
   * referenced resource name
   *
   * @generated from field: string referencedResource = 2;
   */
  referencedResource = "";

  /**
   * if cascade is true, delete/update operations will be cascaded to back referenced resources
   *
   * @generated from field: bool cascade = 3;
   */
  cascade = false;

  constructor(data?: PartialMessage<Reference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.Reference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "referencedResource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cascade", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Reference {
    return new Reference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJsonString(jsonString, options);
  }

  static equals(a: Reference | PlainMessage<Reference> | undefined, b: Reference | PlainMessage<Reference> | undefined): boolean {
    return proto3.util.equals(Reference, a, b);
  }
}

/**
 *
 * source config is to configure resource and bind it to data-source and an entity inside data source.
 * An entity is like a table on sql databases or collection on mongodb etc.
 *
 * @generated from message model.ResourceSourceConfig
 */
export class ResourceSourceConfig extends Message<ResourceSourceConfig> {
  /**
   * data source name: where resource structure and its data will be physically exists. Data source name is required if resource is not virtual
   *
   * @generated from field: string dataSource = 1;
   */
  dataSource = "";

  /**
   * catalog is like a folder/schema/database. It is changing from backend to backend. Basically it is for grouping entities
   *
   * @generated from field: string catalog = 2;
   */
  catalog = "";

  /**
   * entity name an item on datasource backend where resource will be bound. For sql databases it is table name, for mongo it is collection name, etc.
   *
   * @generated from field: string entity = 3;
   */
  entity = "";

  constructor(data?: PartialMessage<ResourceSourceConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.ResourceSourceConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataSource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "catalog", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceSourceConfig {
    return new ResourceSourceConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceSourceConfig {
    return new ResourceSourceConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceSourceConfig {
    return new ResourceSourceConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceSourceConfig | PlainMessage<ResourceSourceConfig> | undefined, b: ResourceSourceConfig | PlainMessage<ResourceSourceConfig> | undefined): boolean {
    return proto3.util.equals(ResourceSourceConfig, a, b);
  }
}

/**
 * @generated from message model.ResourceIndexProperty
 */
export class ResourceIndexProperty extends Message<ResourceIndexProperty> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: model.Order order = 2;
   */
  order = Order.UNKNOWN;

  constructor(data?: PartialMessage<ResourceIndexProperty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.ResourceIndexProperty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order", kind: "enum", T: proto3.getEnumType(Order) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceIndexProperty {
    return new ResourceIndexProperty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceIndexProperty {
    return new ResourceIndexProperty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceIndexProperty {
    return new ResourceIndexProperty().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceIndexProperty | PlainMessage<ResourceIndexProperty> | undefined, b: ResourceIndexProperty | PlainMessage<ResourceIndexProperty> | undefined): boolean {
    return proto3.util.equals(ResourceIndexProperty, a, b);
  }
}

/**
 * @generated from message model.ResourceIndex
 */
export class ResourceIndex extends Message<ResourceIndex> {
  /**
   * list of properties inside single index. Normally you will need only single property. Multi property will be needed for multi property indexes(for complex indexes)
   *
   * @generated from field: repeated model.ResourceIndexProperty properties = 1;
   */
  properties: ResourceIndexProperty[] = [];

  /**
   * Index type(BTREE, HASH)
   *
   * @generated from field: model.ResourceIndexType indexType = 2;
   */
  indexType = ResourceIndexType.BTREE;

  /**
   * if true index will be unique index
   *
   * @generated from field: bool unique = 3;
   */
  unique = false;

  /**
   * @generated from field: map<string, string> annotations = 103;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ResourceIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.ResourceIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "message", T: ResourceIndexProperty, repeated: true },
    { no: 2, name: "indexType", kind: "enum", T: proto3.getEnumType(ResourceIndexType) },
    { no: 3, name: "unique", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 103, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceIndex {
    return new ResourceIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceIndex {
    return new ResourceIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceIndex {
    return new ResourceIndex().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceIndex | PlainMessage<ResourceIndex> | undefined, b: ResourceIndex | PlainMessage<ResourceIndex> | undefined): boolean {
    return proto3.util.equals(ResourceIndex, a, b);
  }
}

/**
 * @generated from message model.ResourceSubType
 */
export class ResourceSubType extends Message<ResourceSubType> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * list of properties of resource. This properties will be used by records of resource. Properties is columns on sql databases. For schemaless data structures properties is only managed by API Brew itself
   *
   * @generated from field: repeated model.ResourceProperty properties = 6;
   */
  properties: ResourceProperty[] = [];

  constructor(data?: PartialMessage<ResourceSubType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.ResourceSubType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "properties", kind: "message", T: ResourceProperty, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceSubType {
    return new ResourceSubType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceSubType {
    return new ResourceSubType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceSubType {
    return new ResourceSubType().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceSubType | PlainMessage<ResourceSubType> | undefined, b: ResourceSubType | PlainMessage<ResourceSubType> | undefined): boolean {
    return proto3.util.equals(ResourceSubType, a, b);
  }
}

/**
 * @generated from message model.Resource
 */
export class Resource extends Message<Resource> {
  /**
   * unique resource id; read only
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * unique resource name, it is unique per namespace
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * each resource is kept inside a namespace. One namespace can have multiple resources
   *
   * @generated from field: string namespace = 3;
   */
  namespace = "";

  /**
   * @generated from field: model.ResourceSourceConfig sourceConfig = 5;
   */
  sourceConfig?: ResourceSourceConfig;

  /**
   * list of properties of resource. This properties will be used by records of resource. Properties is columns on sql databases. For schemaless data structures properties is only managed by API Brew itself
   *
   * @generated from field: repeated model.ResourceProperty properties = 6;
   */
  properties: ResourceProperty[] = [];

  /**
   * @generated from field: repeated model.ResourceSubType types = 7;
   */
  types: ResourceSubType[] = [];

  /**
   * list of resource indexes. Its implementation is depending on data source backend and may not be supported by some backends.
   *
   * @generated from field: repeated model.ResourceIndex indexes = 8;
   */
  indexes: ResourceIndex[] = [];

  /**
   * security context is to apply ACL to resource property
   *
   * @generated from field: model.SecurityContext securityContext = 10;
   */
  securityContext?: SecurityContext;

  /**
   * If virtual is true. Operations will not phisically affect datasource/backend. Virtual resources is for   extension purposes. Their behaviors can be extended and altered. It can also be used to integrate 3rd party systems.
   *
   * @generated from field: bool virtual = 11;
   */
  virtual = false;

  /**
   * if true, delete and update will not be allowed on this resource
   *
   * @generated from field: bool immutable = 12;
   */
  immutable = false;

  /**
   * if abstract, resource is only available to internal and extension side operations
   *
   * @generated from field: bool abstract = 13;
   */
  abstract = false;

  /**
   * @generated from field: optional string title = 14;
   */
  title?: string;

  /**
   * @generated from field: optional string description = 15;
   */
  description?: string;

  /**
   * @generated from field: model.AuditData auditData = 101;
   */
  auditData?: AuditData;

  /**
   * @generated from field: uint32 version = 102;
   */
  version = 0;

  /**
   * @generated from field: map<string, string> annotations = 103;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Resource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.Resource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "sourceConfig", kind: "message", T: ResourceSourceConfig },
    { no: 6, name: "properties", kind: "message", T: ResourceProperty, repeated: true },
    { no: 7, name: "types", kind: "message", T: ResourceSubType, repeated: true },
    { no: 8, name: "indexes", kind: "message", T: ResourceIndex, repeated: true },
    { no: 10, name: "securityContext", kind: "message", T: SecurityContext },
    { no: 11, name: "virtual", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "immutable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "abstract", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 101, name: "auditData", kind: "message", T: AuditData },
    { no: 102, name: "version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 103, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Resource {
    return new Resource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Resource {
    return new Resource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Resource {
    return new Resource().fromJsonString(jsonString, options);
  }

  static equals(a: Resource | PlainMessage<Resource> | undefined, b: Resource | PlainMessage<Resource> | undefined): boolean {
    return proto3.util.equals(Resource, a, b);
  }
}

