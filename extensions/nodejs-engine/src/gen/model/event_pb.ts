// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file model/event.proto (package model, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Resource } from "./resource_pb";
import { Record } from "./record_pb";
import { BooleanExpression } from "./query_pb";

/**
 * @generated from message model.Event
 */
export class Event extends Message<Event> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: model.Event_Action action = 2;
   */
  action = Event_Action.CREATE;

  /**
   * @generated from field: string actionSummary = 3;
   */
  actionSummary = "";

  /**
   * @generated from field: string actionDescription = 4;
   */
  actionDescription = "";

  /**
   * @generated from field: model.Resource resource = 5;
   */
  resource?: Resource;

  /**
   *
   * CREATE,UPDATE - records are for incoming and outgoing records
   * GET - there will be only one record
   * LIST - result of the list operation
   *
   * @generated from field: repeated model.Record records = 6;
   */
  records: Record[] = [];

  /**
   *
   * GET - there will be only one id, for getting record with id
   * DELETE - there will be multiple ids, for deleting multiple records
   *
   * @generated from field: repeated string ids = 7;
   */
  ids: string[] = [];

  /**
   *
   * LIST - search params for the list operation
   *
   * @generated from field: model.Event.RecordSearchParams recordSearchParams = 8;
   */
  recordSearchParams?: Event_RecordSearchParams;

  /**
   *
   * If true, this will be last event on operation list
   *
   * @generated from field: bool finalizes = 9;
   */
  finalizes = false;

  /**
   *
   * If true, backend will wait for processing this event before sending next one on operation list
   *
   * @generated from field: bool sync = 10;
   */
  sync = false;

  /**
   * @generated from field: google.protobuf.Timestamp time = 11;
   */
  time?: Timestamp;

  /**
   *
   * Request annotations
   *
   * @generated from field: map<string, string> annotations = 103;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Event>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.Event";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "action", kind: "enum", T: proto3.getEnumType(Event_Action) },
    { no: 3, name: "actionSummary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "actionDescription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "resource", kind: "message", T: Resource },
    { no: 6, name: "records", kind: "message", T: Record, repeated: true },
    { no: 7, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "recordSearchParams", kind: "message", T: Event_RecordSearchParams },
    { no: 9, name: "finalizes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "sync", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "time", kind: "message", T: Timestamp },
    { no: 103, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event {
    return new Event().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJsonString(jsonString, options);
  }

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean {
    return proto3.util.equals(Event, a, b);
  }
}

/**
 * @generated from enum model.Event_Action
 */
export enum Event_Action {
  /**
   * @generated from enum value: CREATE = 0;
   */
  CREATE = 0,

  /**
   * @generated from enum value: UPDATE = 1;
   */
  UPDATE = 1,

  /**
   * @generated from enum value: DELETE = 2;
   */
  DELETE = 2,

  /**
   * @generated from enum value: GET = 3;
   */
  GET = 3,

  /**
   * @generated from enum value: LIST = 4;
   */
  LIST = 4,

  /**
   * for special cases
   *
   * @generated from enum value: OPERATE = 5;
   */
  OPERATE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Event_Action)
proto3.util.setEnumType(Event_Action, "model.Event_Action", [
  { no: 0, name: "CREATE" },
  { no: 1, name: "UPDATE" },
  { no: 2, name: "DELETE" },
  { no: 3, name: "GET" },
  { no: 4, name: "LIST" },
  { no: 5, name: "OPERATE" },
]);

/**
 * @generated from message model.Event.RecordSearchParams
 */
export class Event_RecordSearchParams extends Message<Event_RecordSearchParams> {
  /**
   * @generated from field: model.BooleanExpression query = 4;
   */
  query?: BooleanExpression;

  /**
   * @generated from field: uint32 limit = 5;
   */
  limit = 0;

  /**
   * @generated from field: uint64 offset = 6;
   */
  offset = protoInt64.zero;

  /**
   * @generated from field: repeated string resolveReferences = 8;
   */
  resolveReferences: string[] = [];

  constructor(data?: PartialMessage<Event_RecordSearchParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.Event.RecordSearchParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "query", kind: "message", T: BooleanExpression },
    { no: 5, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "offset", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "resolveReferences", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event_RecordSearchParams {
    return new Event_RecordSearchParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event_RecordSearchParams {
    return new Event_RecordSearchParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event_RecordSearchParams {
    return new Event_RecordSearchParams().fromJsonString(jsonString, options);
  }

  static equals(a: Event_RecordSearchParams | PlainMessage<Event_RecordSearchParams> | undefined, b: Event_RecordSearchParams | PlainMessage<Event_RecordSearchParams> | undefined): boolean {
    return proto3.util.equals(Event_RecordSearchParams, a, b);
  }
}

/**
 *
 * Events pass through selectors, if selector returns true, event will be processed
 * Selector returns true if no selector fails.
 * For example, if you passed empty selector, it will return true for all events.
 *
 * @generated from message model.EventSelector
 */
export class EventSelector extends Message<EventSelector> {
  /**
   * @generated from field: repeated model.Event_Action actions = 1;
   */
  actions: Event_Action[] = [];

  /**
   * @generated from field: model.BooleanExpression recordSelector = 2;
   */
  recordSelector?: BooleanExpression;

  /**
   * @generated from field: repeated string namespaces = 3;
   */
  namespaces: string[] = [];

  /**
   * @generated from field: repeated string resources = 4;
   */
  resources: string[] = [];

  /**
   *
   * star means all
   *
   * @generated from field: repeated string ids = 7;
   */
  ids: string[] = [];

  /**
   *
   * star means all, empty means proceed
   *
   * @generated from field: map<string, string> annotations = 103;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<EventSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.EventSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actions", kind: "enum", T: proto3.getEnumType(Event_Action), repeated: true },
    { no: 2, name: "recordSelector", kind: "message", T: BooleanExpression },
    { no: 3, name: "namespaces", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "resources", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 103, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSelector {
    return new EventSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSelector {
    return new EventSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSelector {
    return new EventSelector().fromJsonString(jsonString, options);
  }

  static equals(a: EventSelector | PlainMessage<EventSelector> | undefined, b: EventSelector | PlainMessage<EventSelector> | undefined): boolean {
    return proto3.util.equals(EventSelector, a, b);
  }
}

