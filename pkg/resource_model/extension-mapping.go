// AUTOGENERATED FILE

//go:build !codeanalysis

package resource_model

import (
	"github.com/apibrew/apibrew/pkg/abs"
	"github.com/apibrew/apibrew/pkg/model"
	"github.com/apibrew/apibrew/pkg/types"
	"google.golang.org/protobuf/types/known/structpb"
)

import "github.com/google/uuid"
import "github.com/apibrew/apibrew/pkg/formats/unstructured"
import "time"

type ExtensionMapper struct {
}

func NewExtensionMapper() *ExtensionMapper {
	return &ExtensionMapper{}
}

var ExtensionMapperInstance = NewExtensionMapper()

func (m *ExtensionMapper) New() *Extension {
	return &Extension{}
}

func (m *ExtensionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionMapper) ToRecord(extension *Extension) *model.Record {
	var rec = &model.Record{}
	rec.Properties = m.ToProperties(extension)
	return rec
}

func (m *ExtensionMapper) FromRecord(record *model.Record) *Extension {
	return m.FromProperties(record.Properties)
}

func (m *ExtensionMapper) ToProperties(extension *Extension) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Id := extension.Id

	if var_Id != nil {
		var var_Id_mapped *structpb.Value

		var var_Id_err error
		var_Id_mapped, var_Id_err = types.ByResourcePropertyType(model.ResourceProperty_UUID).Pack(*var_Id)
		if var_Id_err != nil {
			panic(var_Id_err)
		}
		properties["id"] = var_Id_mapped
	}

	var_Version := extension.Version

	var var_Version_mapped *structpb.Value

	var var_Version_err error
	var_Version_mapped, var_Version_err = types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Version)
	if var_Version_err != nil {
		panic(var_Version_err)
	}
	properties["version"] = var_Version_mapped

	var_AuditData := extension.AuditData

	if var_AuditData != nil {
		var var_AuditData_mapped *structpb.Value

		var_AuditData_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionAuditDataMapperInstance.ToProperties(var_AuditData)})
		properties["auditData"] = var_AuditData_mapped
	}

	var_Name := extension.Name

	var var_Name_mapped *structpb.Value

	var var_Name_err error
	var_Name_mapped, var_Name_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Name)
	if var_Name_err != nil {
		panic(var_Name_err)
	}
	properties["name"] = var_Name_mapped

	var_Description := extension.Description

	if var_Description != nil {
		var var_Description_mapped *structpb.Value

		var var_Description_err error
		var_Description_mapped, var_Description_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Description)
		if var_Description_err != nil {
			panic(var_Description_err)
		}
		properties["description"] = var_Description_mapped
	}

	var_Selector := extension.Selector

	if var_Selector != nil {
		var var_Selector_mapped *structpb.Value

		var_Selector_mapped = structpb.NewStructValue(&structpb.Struct{Fields: EventSelectorMapperInstance.ToProperties(var_Selector)})
		properties["selector"] = var_Selector_mapped
	}

	var_Order := extension.Order

	var var_Order_mapped *structpb.Value

	var var_Order_err error
	var_Order_mapped, var_Order_err = types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Order)
	if var_Order_err != nil {
		panic(var_Order_err)
	}
	properties["order"] = var_Order_mapped

	var_Finalizes := extension.Finalizes

	var var_Finalizes_mapped *structpb.Value

	var var_Finalizes_err error
	var_Finalizes_mapped, var_Finalizes_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Finalizes)
	if var_Finalizes_err != nil {
		panic(var_Finalizes_err)
	}
	properties["finalizes"] = var_Finalizes_mapped

	var_Sync := extension.Sync

	var var_Sync_mapped *structpb.Value

	var var_Sync_err error
	var_Sync_mapped, var_Sync_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Sync)
	if var_Sync_err != nil {
		panic(var_Sync_err)
	}
	properties["sync"] = var_Sync_mapped

	var_Responds := extension.Responds

	var var_Responds_mapped *structpb.Value

	var var_Responds_err error
	var_Responds_mapped, var_Responds_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Responds)
	if var_Responds_err != nil {
		panic(var_Responds_err)
	}
	properties["responds"] = var_Responds_mapped

	var_Call := extension.Call

	var var_Call_mapped *structpb.Value

	var_Call_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExternalCallMapperInstance.ToProperties(&var_Call)})
	properties["call"] = var_Call_mapped

	var_Annotations := extension.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped *structpb.Value

		var var_Annotations_st *structpb.Struct = new(structpb.Struct)
		var_Annotations_st.Fields = make(map[string]*structpb.Value)
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped *structpb.Value

			var var_1x_err error
			var_1x_mapped, var_1x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_1x)
			if var_1x_err != nil {
				panic(var_1x_err)
			}

			var_Annotations_st.Fields[key] = var_1x_mapped
		}
		var_Annotations_mapped = structpb.NewStructValue(var_Annotations_st)
		properties["annotations"] = var_Annotations_mapped
	}
	return properties
}

func (m *ExtensionMapper) FromProperties(properties map[string]*structpb.Value) *Extension {
	var s = m.New()
	if properties["id"] != nil && properties["id"].AsInterface() != nil {

		var_Id := properties["id"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_UUID).UnPack(var_Id)

		if err != nil {
			panic(err)
		}

		var_Id_mapped := new(uuid.UUID)
		*var_Id_mapped = val.(uuid.UUID)

		s.Id = var_Id_mapped
	}
	if properties["version"] != nil && properties["version"].AsInterface() != nil {

		var_Version := properties["version"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Version)

		if err != nil {
			panic(err)
		}

		var_Version_mapped := val.(int32)

		s.Version = var_Version_mapped
	}
	if properties["auditData"] != nil && properties["auditData"].AsInterface() != nil {

		var_AuditData := properties["auditData"]
		var mappedValue = ExtensionAuditDataMapperInstance.FromProperties(var_AuditData.GetStructValue().Fields)

		var_AuditData_mapped := mappedValue

		s.AuditData = var_AuditData_mapped
	}
	if properties["name"] != nil && properties["name"].AsInterface() != nil {

		var_Name := properties["name"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Name)

		if err != nil {
			panic(err)
		}

		var_Name_mapped := val.(string)

		s.Name = var_Name_mapped
	}
	if properties["description"] != nil && properties["description"].AsInterface() != nil {

		var_Description := properties["description"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Description)

		if err != nil {
			panic(err)
		}

		var_Description_mapped := new(string)
		*var_Description_mapped = val.(string)

		s.Description = var_Description_mapped
	}
	if properties["selector"] != nil && properties["selector"].AsInterface() != nil {

		var_Selector := properties["selector"]
		var mappedValue = EventSelectorMapperInstance.FromProperties(var_Selector.GetStructValue().Fields)

		var_Selector_mapped := mappedValue

		s.Selector = var_Selector_mapped
	}
	if properties["order"] != nil && properties["order"].AsInterface() != nil {

		var_Order := properties["order"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Order)

		if err != nil {
			panic(err)
		}

		var_Order_mapped := val.(int32)

		s.Order = var_Order_mapped
	}
	if properties["finalizes"] != nil && properties["finalizes"].AsInterface() != nil {

		var_Finalizes := properties["finalizes"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Finalizes)

		if err != nil {
			panic(err)
		}

		var_Finalizes_mapped := val.(bool)

		s.Finalizes = var_Finalizes_mapped
	}
	if properties["sync"] != nil && properties["sync"].AsInterface() != nil {

		var_Sync := properties["sync"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Sync)

		if err != nil {
			panic(err)
		}

		var_Sync_mapped := val.(bool)

		s.Sync = var_Sync_mapped
	}
	if properties["responds"] != nil && properties["responds"].AsInterface() != nil {

		var_Responds := properties["responds"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Responds)

		if err != nil {
			panic(err)
		}

		var_Responds_mapped := val.(bool)

		s.Responds = var_Responds_mapped
	}
	if properties["call"] != nil && properties["call"].AsInterface() != nil {

		var_Call := properties["call"]
		var mappedValue = ExternalCallMapperInstance.FromProperties(var_Call.GetStructValue().Fields)

		var_Call_mapped := *mappedValue

		s.Call = var_Call_mapped
	}
	if properties["annotations"] != nil && properties["annotations"].AsInterface() != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.GetStructValue().Fields {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	return s
}

type ExtensionBooleanExpressionMapper struct {
}

func NewExtensionBooleanExpressionMapper() *ExtensionBooleanExpressionMapper {
	return &ExtensionBooleanExpressionMapper{}
}

var ExtensionBooleanExpressionMapperInstance = NewExtensionBooleanExpressionMapper()

func (m *ExtensionBooleanExpressionMapper) New() *ExtensionBooleanExpression {
	return &ExtensionBooleanExpression{}
}

func (m *ExtensionBooleanExpressionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionBooleanExpressionMapper) ToProperties(extensionBooleanExpression *ExtensionBooleanExpression) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_And := extensionBooleanExpression.And

	if var_And != nil {
		var var_And_mapped *structpb.Value

		var var_And_l []*structpb.Value
		for _, value := range var_And {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var_5x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionBooleanExpressionMapperInstance.ToProperties(&var_5x)})

			var_And_l = append(var_And_l, var_5x_mapped)
		}
		var_And_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_And_l})
		properties["and"] = var_And_mapped
	}

	var_Or := extensionBooleanExpression.Or

	if var_Or != nil {
		var var_Or_mapped *structpb.Value

		var var_Or_l []*structpb.Value
		for _, value := range var_Or {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var_5x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionBooleanExpressionMapperInstance.ToProperties(&var_5x)})

			var_Or_l = append(var_Or_l, var_5x_mapped)
		}
		var_Or_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Or_l})
		properties["or"] = var_Or_mapped
	}

	var_Not := extensionBooleanExpression.Not

	if var_Not != nil {
		var var_Not_mapped *structpb.Value

		var_Not_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionBooleanExpressionMapperInstance.ToProperties(var_Not)})
		properties["not"] = var_Not_mapped
	}

	var_Equal := extensionBooleanExpression.Equal

	if var_Equal != nil {
		var var_Equal_mapped *structpb.Value

		var_Equal_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionPairExpressionMapperInstance.ToProperties(var_Equal)})
		properties["equal"] = var_Equal_mapped
	}

	var_LessThan := extensionBooleanExpression.LessThan

	if var_LessThan != nil {
		var var_LessThan_mapped *structpb.Value

		var_LessThan_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionPairExpressionMapperInstance.ToProperties(var_LessThan)})
		properties["lessThan"] = var_LessThan_mapped
	}

	var_GreaterThan := extensionBooleanExpression.GreaterThan

	if var_GreaterThan != nil {
		var var_GreaterThan_mapped *structpb.Value

		var_GreaterThan_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionPairExpressionMapperInstance.ToProperties(var_GreaterThan)})
		properties["greaterThan"] = var_GreaterThan_mapped
	}

	var_LessThanOrEqual := extensionBooleanExpression.LessThanOrEqual

	if var_LessThanOrEqual != nil {
		var var_LessThanOrEqual_mapped *structpb.Value

		var_LessThanOrEqual_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionPairExpressionMapperInstance.ToProperties(var_LessThanOrEqual)})
		properties["lessThanOrEqual"] = var_LessThanOrEqual_mapped
	}

	var_GreaterThanOrEqual := extensionBooleanExpression.GreaterThanOrEqual

	if var_GreaterThanOrEqual != nil {
		var var_GreaterThanOrEqual_mapped *structpb.Value

		var_GreaterThanOrEqual_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionPairExpressionMapperInstance.ToProperties(var_GreaterThanOrEqual)})
		properties["greaterThanOrEqual"] = var_GreaterThanOrEqual_mapped
	}

	var_In := extensionBooleanExpression.In

	if var_In != nil {
		var var_In_mapped *structpb.Value

		var_In_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionPairExpressionMapperInstance.ToProperties(var_In)})
		properties["in"] = var_In_mapped
	}

	var_IsNull := extensionBooleanExpression.IsNull

	if var_IsNull != nil {
		var var_IsNull_mapped *structpb.Value

		var_IsNull_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionExpressionMapperInstance.ToProperties(var_IsNull)})
		properties["isNull"] = var_IsNull_mapped
	}

	var_RegexMatch := extensionBooleanExpression.RegexMatch

	if var_RegexMatch != nil {
		var var_RegexMatch_mapped *structpb.Value

		var_RegexMatch_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionRegexMatchExpressionMapperInstance.ToProperties(var_RegexMatch)})
		properties["regexMatch"] = var_RegexMatch_mapped
	}
	return properties
}

func (m *ExtensionBooleanExpressionMapper) FromProperties(properties map[string]*structpb.Value) *ExtensionBooleanExpression {
	var s = m.New()
	if properties["and"] != nil && properties["and"].AsInterface() != nil {

		var_And := properties["and"]
		var_And_mapped := []ExtensionBooleanExpression{}
		for _, v := range var_And.GetListValue().Values {

			var_4x := v
			var mappedValue = ExtensionBooleanExpressionMapperInstance.FromProperties(var_4x.GetStructValue().Fields)

			var_4x_mapped := *mappedValue

			var_And_mapped = append(var_And_mapped, var_4x_mapped)
		}

		s.And = var_And_mapped
	}
	if properties["or"] != nil && properties["or"].AsInterface() != nil {

		var_Or := properties["or"]
		var_Or_mapped := []ExtensionBooleanExpression{}
		for _, v := range var_Or.GetListValue().Values {

			var_4x := v
			var mappedValue = ExtensionBooleanExpressionMapperInstance.FromProperties(var_4x.GetStructValue().Fields)

			var_4x_mapped := *mappedValue

			var_Or_mapped = append(var_Or_mapped, var_4x_mapped)
		}

		s.Or = var_Or_mapped
	}
	if properties["not"] != nil && properties["not"].AsInterface() != nil {

		var_Not := properties["not"]
		var mappedValue = ExtensionBooleanExpressionMapperInstance.FromProperties(var_Not.GetStructValue().Fields)

		var_Not_mapped := mappedValue

		s.Not = var_Not_mapped
	}
	if properties["equal"] != nil && properties["equal"].AsInterface() != nil {

		var_Equal := properties["equal"]
		var mappedValue = ExtensionPairExpressionMapperInstance.FromProperties(var_Equal.GetStructValue().Fields)

		var_Equal_mapped := mappedValue

		s.Equal = var_Equal_mapped
	}
	if properties["lessThan"] != nil && properties["lessThan"].AsInterface() != nil {

		var_LessThan := properties["lessThan"]
		var mappedValue = ExtensionPairExpressionMapperInstance.FromProperties(var_LessThan.GetStructValue().Fields)

		var_LessThan_mapped := mappedValue

		s.LessThan = var_LessThan_mapped
	}
	if properties["greaterThan"] != nil && properties["greaterThan"].AsInterface() != nil {

		var_GreaterThan := properties["greaterThan"]
		var mappedValue = ExtensionPairExpressionMapperInstance.FromProperties(var_GreaterThan.GetStructValue().Fields)

		var_GreaterThan_mapped := mappedValue

		s.GreaterThan = var_GreaterThan_mapped
	}
	if properties["lessThanOrEqual"] != nil && properties["lessThanOrEqual"].AsInterface() != nil {

		var_LessThanOrEqual := properties["lessThanOrEqual"]
		var mappedValue = ExtensionPairExpressionMapperInstance.FromProperties(var_LessThanOrEqual.GetStructValue().Fields)

		var_LessThanOrEqual_mapped := mappedValue

		s.LessThanOrEqual = var_LessThanOrEqual_mapped
	}
	if properties["greaterThanOrEqual"] != nil && properties["greaterThanOrEqual"].AsInterface() != nil {

		var_GreaterThanOrEqual := properties["greaterThanOrEqual"]
		var mappedValue = ExtensionPairExpressionMapperInstance.FromProperties(var_GreaterThanOrEqual.GetStructValue().Fields)

		var_GreaterThanOrEqual_mapped := mappedValue

		s.GreaterThanOrEqual = var_GreaterThanOrEqual_mapped
	}
	if properties["in"] != nil && properties["in"].AsInterface() != nil {

		var_In := properties["in"]
		var mappedValue = ExtensionPairExpressionMapperInstance.FromProperties(var_In.GetStructValue().Fields)

		var_In_mapped := mappedValue

		s.In = var_In_mapped
	}
	if properties["isNull"] != nil && properties["isNull"].AsInterface() != nil {

		var_IsNull := properties["isNull"]
		var mappedValue = ExtensionExpressionMapperInstance.FromProperties(var_IsNull.GetStructValue().Fields)

		var_IsNull_mapped := mappedValue

		s.IsNull = var_IsNull_mapped
	}
	if properties["regexMatch"] != nil && properties["regexMatch"].AsInterface() != nil {

		var_RegexMatch := properties["regexMatch"]
		var mappedValue = ExtensionRegexMatchExpressionMapperInstance.FromProperties(var_RegexMatch.GetStructValue().Fields)

		var_RegexMatch_mapped := mappedValue

		s.RegexMatch = var_RegexMatch_mapped
	}
	return s
}

type ExtensionPairExpressionMapper struct {
}

func NewExtensionPairExpressionMapper() *ExtensionPairExpressionMapper {
	return &ExtensionPairExpressionMapper{}
}

var ExtensionPairExpressionMapperInstance = NewExtensionPairExpressionMapper()

func (m *ExtensionPairExpressionMapper) New() *ExtensionPairExpression {
	return &ExtensionPairExpression{}
}

func (m *ExtensionPairExpressionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionPairExpressionMapper) ToProperties(extensionPairExpression *ExtensionPairExpression) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Left := extensionPairExpression.Left

	if var_Left != nil {
		var var_Left_mapped *structpb.Value

		var_Left_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionExpressionMapperInstance.ToProperties(var_Left)})
		properties["left"] = var_Left_mapped
	}

	var_Right := extensionPairExpression.Right

	if var_Right != nil {
		var var_Right_mapped *structpb.Value

		var_Right_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionExpressionMapperInstance.ToProperties(var_Right)})
		properties["right"] = var_Right_mapped
	}
	return properties
}

func (m *ExtensionPairExpressionMapper) FromProperties(properties map[string]*structpb.Value) *ExtensionPairExpression {
	var s = m.New()
	if properties["left"] != nil && properties["left"].AsInterface() != nil {

		var_Left := properties["left"]
		var mappedValue = ExtensionExpressionMapperInstance.FromProperties(var_Left.GetStructValue().Fields)

		var_Left_mapped := mappedValue

		s.Left = var_Left_mapped
	}
	if properties["right"] != nil && properties["right"].AsInterface() != nil {

		var_Right := properties["right"]
		var mappedValue = ExtensionExpressionMapperInstance.FromProperties(var_Right.GetStructValue().Fields)

		var_Right_mapped := mappedValue

		s.Right = var_Right_mapped
	}
	return s
}

type ExtensionRegexMatchExpressionMapper struct {
}

func NewExtensionRegexMatchExpressionMapper() *ExtensionRegexMatchExpressionMapper {
	return &ExtensionRegexMatchExpressionMapper{}
}

var ExtensionRegexMatchExpressionMapperInstance = NewExtensionRegexMatchExpressionMapper()

func (m *ExtensionRegexMatchExpressionMapper) New() *ExtensionRegexMatchExpression {
	return &ExtensionRegexMatchExpression{}
}

func (m *ExtensionRegexMatchExpressionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionRegexMatchExpressionMapper) ToProperties(extensionRegexMatchExpression *ExtensionRegexMatchExpression) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Pattern := extensionRegexMatchExpression.Pattern

	if var_Pattern != nil {
		var var_Pattern_mapped *structpb.Value

		var var_Pattern_err error
		var_Pattern_mapped, var_Pattern_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Pattern)
		if var_Pattern_err != nil {
			panic(var_Pattern_err)
		}
		properties["pattern"] = var_Pattern_mapped
	}

	var_Expression := extensionRegexMatchExpression.Expression

	if var_Expression != nil {
		var var_Expression_mapped *structpb.Value

		var_Expression_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionExpressionMapperInstance.ToProperties(var_Expression)})
		properties["expression"] = var_Expression_mapped
	}
	return properties
}

func (m *ExtensionRegexMatchExpressionMapper) FromProperties(properties map[string]*structpb.Value) *ExtensionRegexMatchExpression {
	var s = m.New()
	if properties["pattern"] != nil && properties["pattern"].AsInterface() != nil {

		var_Pattern := properties["pattern"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Pattern)

		if err != nil {
			panic(err)
		}

		var_Pattern_mapped := new(string)
		*var_Pattern_mapped = val.(string)

		s.Pattern = var_Pattern_mapped
	}
	if properties["expression"] != nil && properties["expression"].AsInterface() != nil {

		var_Expression := properties["expression"]
		var mappedValue = ExtensionExpressionMapperInstance.FromProperties(var_Expression.GetStructValue().Fields)

		var_Expression_mapped := mappedValue

		s.Expression = var_Expression_mapped
	}
	return s
}

type ExtensionExpressionMapper struct {
}

func NewExtensionExpressionMapper() *ExtensionExpressionMapper {
	return &ExtensionExpressionMapper{}
}

var ExtensionExpressionMapperInstance = NewExtensionExpressionMapper()

func (m *ExtensionExpressionMapper) New() *ExtensionExpression {
	return &ExtensionExpression{}
}

func (m *ExtensionExpressionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionExpressionMapper) ToProperties(extensionExpression *ExtensionExpression) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Property := extensionExpression.Property

	if var_Property != nil {
		var var_Property_mapped *structpb.Value

		var var_Property_err error
		var_Property_mapped, var_Property_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Property)
		if var_Property_err != nil {
			panic(var_Property_err)
		}
		properties["property"] = var_Property_mapped
	}

	var_Value := extensionExpression.Value

	if var_Value != nil {
		var var_Value_mapped *structpb.Value

		var var_Value_err error
		var_Value_mapped, var_Value_err = types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_Value)
		if var_Value_err != nil {
			panic(var_Value_err)
		}
		properties["value"] = var_Value_mapped
	}
	return properties
}

func (m *ExtensionExpressionMapper) FromProperties(properties map[string]*structpb.Value) *ExtensionExpression {
	var s = m.New()
	if properties["property"] != nil && properties["property"].AsInterface() != nil {

		var_Property := properties["property"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Property)

		if err != nil {
			panic(err)
		}

		var_Property_mapped := new(string)
		*var_Property_mapped = val.(string)

		s.Property = var_Property_mapped
	}
	if properties["value"] != nil && properties["value"].AsInterface() != nil {

		var_Value := properties["value"]
		var_Value_mapped := new(interface{})
		*var_Value_mapped = unstructured.FromValue(var_Value)

		s.Value = var_Value_mapped
	}
	return s
}

type ExtensionAuditDataMapper struct {
}

func NewExtensionAuditDataMapper() *ExtensionAuditDataMapper {
	return &ExtensionAuditDataMapper{}
}

var ExtensionAuditDataMapperInstance = NewExtensionAuditDataMapper()

func (m *ExtensionAuditDataMapper) New() *ExtensionAuditData {
	return &ExtensionAuditData{}
}

func (m *ExtensionAuditDataMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionAuditDataMapper) ToProperties(extensionAuditData *ExtensionAuditData) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_CreatedBy := extensionAuditData.CreatedBy

	if var_CreatedBy != nil {
		var var_CreatedBy_mapped *structpb.Value

		var var_CreatedBy_err error
		var_CreatedBy_mapped, var_CreatedBy_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_CreatedBy)
		if var_CreatedBy_err != nil {
			panic(var_CreatedBy_err)
		}
		properties["createdBy"] = var_CreatedBy_mapped
	}

	var_UpdatedBy := extensionAuditData.UpdatedBy

	if var_UpdatedBy != nil {
		var var_UpdatedBy_mapped *structpb.Value

		var var_UpdatedBy_err error
		var_UpdatedBy_mapped, var_UpdatedBy_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_UpdatedBy)
		if var_UpdatedBy_err != nil {
			panic(var_UpdatedBy_err)
		}
		properties["updatedBy"] = var_UpdatedBy_mapped
	}

	var_CreatedOn := extensionAuditData.CreatedOn

	if var_CreatedOn != nil {
		var var_CreatedOn_mapped *structpb.Value

		var var_CreatedOn_err error
		var_CreatedOn_mapped, var_CreatedOn_err = types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(*var_CreatedOn)
		if var_CreatedOn_err != nil {
			panic(var_CreatedOn_err)
		}
		properties["createdOn"] = var_CreatedOn_mapped
	}

	var_UpdatedOn := extensionAuditData.UpdatedOn

	if var_UpdatedOn != nil {
		var var_UpdatedOn_mapped *structpb.Value

		var var_UpdatedOn_err error
		var_UpdatedOn_mapped, var_UpdatedOn_err = types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(*var_UpdatedOn)
		if var_UpdatedOn_err != nil {
			panic(var_UpdatedOn_err)
		}
		properties["updatedOn"] = var_UpdatedOn_mapped
	}
	return properties
}

func (m *ExtensionAuditDataMapper) FromProperties(properties map[string]*structpb.Value) *ExtensionAuditData {
	var s = m.New()
	if properties["createdBy"] != nil && properties["createdBy"].AsInterface() != nil {

		var_CreatedBy := properties["createdBy"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_CreatedBy)

		if err != nil {
			panic(err)
		}

		var_CreatedBy_mapped := new(string)
		*var_CreatedBy_mapped = val.(string)

		s.CreatedBy = var_CreatedBy_mapped
	}
	if properties["updatedBy"] != nil && properties["updatedBy"].AsInterface() != nil {

		var_UpdatedBy := properties["updatedBy"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_UpdatedBy)

		if err != nil {
			panic(err)
		}

		var_UpdatedBy_mapped := new(string)
		*var_UpdatedBy_mapped = val.(string)

		s.UpdatedBy = var_UpdatedBy_mapped
	}
	if properties["createdOn"] != nil && properties["createdOn"].AsInterface() != nil {

		var_CreatedOn := properties["createdOn"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_CreatedOn)

		if err != nil {
			panic(err)
		}

		var_CreatedOn_mapped := new(time.Time)
		*var_CreatedOn_mapped = val.(time.Time)

		s.CreatedOn = var_CreatedOn_mapped
	}
	if properties["updatedOn"] != nil && properties["updatedOn"].AsInterface() != nil {

		var_UpdatedOn := properties["updatedOn"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_UpdatedOn)

		if err != nil {
			panic(err)
		}

		var_UpdatedOn_mapped := new(time.Time)
		*var_UpdatedOn_mapped = val.(time.Time)

		s.UpdatedOn = var_UpdatedOn_mapped
	}
	return s
}

type FunctionCallMapper struct {
}

func NewFunctionCallMapper() *FunctionCallMapper {
	return &FunctionCallMapper{}
}

var FunctionCallMapperInstance = NewFunctionCallMapper()

func (m *FunctionCallMapper) New() *FunctionCall {
	return &FunctionCall{}
}

func (m *FunctionCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *FunctionCallMapper) ToProperties(functionCall *FunctionCall) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Host := functionCall.Host

	var var_Host_mapped *structpb.Value

	var var_Host_err error
	var_Host_mapped, var_Host_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Host)
	if var_Host_err != nil {
		panic(var_Host_err)
	}
	properties["host"] = var_Host_mapped

	var_FunctionName := functionCall.FunctionName

	var var_FunctionName_mapped *structpb.Value

	var var_FunctionName_err error
	var_FunctionName_mapped, var_FunctionName_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_FunctionName)
	if var_FunctionName_err != nil {
		panic(var_FunctionName_err)
	}
	properties["functionName"] = var_FunctionName_mapped
	return properties
}

func (m *FunctionCallMapper) FromProperties(properties map[string]*structpb.Value) *FunctionCall {
	var s = m.New()
	if properties["host"] != nil && properties["host"].AsInterface() != nil {

		var_Host := properties["host"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Host)

		if err != nil {
			panic(err)
		}

		var_Host_mapped := val.(string)

		s.Host = var_Host_mapped
	}
	if properties["functionName"] != nil && properties["functionName"].AsInterface() != nil {

		var_FunctionName := properties["functionName"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_FunctionName)

		if err != nil {
			panic(err)
		}

		var_FunctionName_mapped := val.(string)

		s.FunctionName = var_FunctionName_mapped
	}
	return s
}

type HttpCallMapper struct {
}

func NewHttpCallMapper() *HttpCallMapper {
	return &HttpCallMapper{}
}

var HttpCallMapperInstance = NewHttpCallMapper()

func (m *HttpCallMapper) New() *HttpCall {
	return &HttpCall{}
}

func (m *HttpCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *HttpCallMapper) ToProperties(httpCall *HttpCall) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Uri := httpCall.Uri

	var var_Uri_mapped *structpb.Value

	var var_Uri_err error
	var_Uri_mapped, var_Uri_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Uri)
	if var_Uri_err != nil {
		panic(var_Uri_err)
	}
	properties["uri"] = var_Uri_mapped

	var_Method := httpCall.Method

	var var_Method_mapped *structpb.Value

	var var_Method_err error
	var_Method_mapped, var_Method_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Method)
	if var_Method_err != nil {
		panic(var_Method_err)
	}
	properties["method"] = var_Method_mapped
	return properties
}

func (m *HttpCallMapper) FromProperties(properties map[string]*structpb.Value) *HttpCall {
	var s = m.New()
	if properties["uri"] != nil && properties["uri"].AsInterface() != nil {

		var_Uri := properties["uri"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Uri)

		if err != nil {
			panic(err)
		}

		var_Uri_mapped := val.(string)

		s.Uri = var_Uri_mapped
	}
	if properties["method"] != nil && properties["method"].AsInterface() != nil {

		var_Method := properties["method"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Method)

		if err != nil {
			panic(err)
		}

		var_Method_mapped := val.(string)

		s.Method = var_Method_mapped
	}
	return s
}

type ChannelCallMapper struct {
}

func NewChannelCallMapper() *ChannelCallMapper {
	return &ChannelCallMapper{}
}

var ChannelCallMapperInstance = NewChannelCallMapper()

func (m *ChannelCallMapper) New() *ChannelCall {
	return &ChannelCall{}
}

func (m *ChannelCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ChannelCallMapper) ToProperties(channelCall *ChannelCall) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_ChannelKey := channelCall.ChannelKey

	var var_ChannelKey_mapped *structpb.Value

	var var_ChannelKey_err error
	var_ChannelKey_mapped, var_ChannelKey_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_ChannelKey)
	if var_ChannelKey_err != nil {
		panic(var_ChannelKey_err)
	}
	properties["channelKey"] = var_ChannelKey_mapped
	return properties
}

func (m *ChannelCallMapper) FromProperties(properties map[string]*structpb.Value) *ChannelCall {
	var s = m.New()
	if properties["channelKey"] != nil && properties["channelKey"].AsInterface() != nil {

		var_ChannelKey := properties["channelKey"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_ChannelKey)

		if err != nil {
			panic(err)
		}

		var_ChannelKey_mapped := val.(string)

		s.ChannelKey = var_ChannelKey_mapped
	}
	return s
}

type ExternalCallMapper struct {
}

func NewExternalCallMapper() *ExternalCallMapper {
	return &ExternalCallMapper{}
}

var ExternalCallMapperInstance = NewExternalCallMapper()

func (m *ExternalCallMapper) New() *ExternalCall {
	return &ExternalCall{}
}

func (m *ExternalCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExternalCallMapper) ToProperties(externalCall *ExternalCall) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_FunctionCall := externalCall.FunctionCall

	if var_FunctionCall != nil {
		var var_FunctionCall_mapped *structpb.Value

		var_FunctionCall_mapped = structpb.NewStructValue(&structpb.Struct{Fields: FunctionCallMapperInstance.ToProperties(var_FunctionCall)})
		properties["functionCall"] = var_FunctionCall_mapped
	}

	var_HttpCall := externalCall.HttpCall

	if var_HttpCall != nil {
		var var_HttpCall_mapped *structpb.Value

		var_HttpCall_mapped = structpb.NewStructValue(&structpb.Struct{Fields: HttpCallMapperInstance.ToProperties(var_HttpCall)})
		properties["httpCall"] = var_HttpCall_mapped
	}

	var_ChannelCall := externalCall.ChannelCall

	if var_ChannelCall != nil {
		var var_ChannelCall_mapped *structpb.Value

		var_ChannelCall_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ChannelCallMapperInstance.ToProperties(var_ChannelCall)})
		properties["channelCall"] = var_ChannelCall_mapped
	}
	return properties
}

func (m *ExternalCallMapper) FromProperties(properties map[string]*structpb.Value) *ExternalCall {
	var s = m.New()
	if properties["functionCall"] != nil && properties["functionCall"].AsInterface() != nil {

		var_FunctionCall := properties["functionCall"]
		var mappedValue = FunctionCallMapperInstance.FromProperties(var_FunctionCall.GetStructValue().Fields)

		var_FunctionCall_mapped := mappedValue

		s.FunctionCall = var_FunctionCall_mapped
	}
	if properties["httpCall"] != nil && properties["httpCall"].AsInterface() != nil {

		var_HttpCall := properties["httpCall"]
		var mappedValue = HttpCallMapperInstance.FromProperties(var_HttpCall.GetStructValue().Fields)

		var_HttpCall_mapped := mappedValue

		s.HttpCall = var_HttpCall_mapped
	}
	if properties["channelCall"] != nil && properties["channelCall"].AsInterface() != nil {

		var_ChannelCall := properties["channelCall"]
		var mappedValue = ChannelCallMapperInstance.FromProperties(var_ChannelCall.GetStructValue().Fields)

		var_ChannelCall_mapped := mappedValue

		s.ChannelCall = var_ChannelCall_mapped
	}
	return s
}

type EventSelectorMapper struct {
}

func NewEventSelectorMapper() *EventSelectorMapper {
	return &EventSelectorMapper{}
}

var EventSelectorMapperInstance = NewEventSelectorMapper()

func (m *EventSelectorMapper) New() *EventSelector {
	return &EventSelector{}
}

func (m *EventSelectorMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *EventSelectorMapper) ToProperties(eventSelector *EventSelector) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Actions := eventSelector.Actions

	if var_Actions != nil {
		var var_Actions_mapped *structpb.Value

		var var_Actions_l []*structpb.Value
		for _, value := range var_Actions {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var var_5x_err error
			var_5x_mapped, var_5x_err = types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(string(var_5x))
			if var_5x_err != nil {
				panic(var_5x_err)
			}

			var_Actions_l = append(var_Actions_l, var_5x_mapped)
		}
		var_Actions_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Actions_l})
		properties["actions"] = var_Actions_mapped
	}

	var_RecordSelector := eventSelector.RecordSelector

	if var_RecordSelector != nil {
		var var_RecordSelector_mapped *structpb.Value

		var_RecordSelector_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionBooleanExpressionMapperInstance.ToProperties(var_RecordSelector)})
		properties["recordSelector"] = var_RecordSelector_mapped
	}

	var_Namespaces := eventSelector.Namespaces

	if var_Namespaces != nil {
		var var_Namespaces_mapped *structpb.Value

		var var_Namespaces_l []*structpb.Value
		for _, value := range var_Namespaces {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var var_5x_err error
			var_5x_mapped, var_5x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_5x)
			if var_5x_err != nil {
				panic(var_5x_err)
			}

			var_Namespaces_l = append(var_Namespaces_l, var_5x_mapped)
		}
		var_Namespaces_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Namespaces_l})
		properties["namespaces"] = var_Namespaces_mapped
	}

	var_Resources := eventSelector.Resources

	if var_Resources != nil {
		var var_Resources_mapped *structpb.Value

		var var_Resources_l []*structpb.Value
		for _, value := range var_Resources {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var var_5x_err error
			var_5x_mapped, var_5x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_5x)
			if var_5x_err != nil {
				panic(var_5x_err)
			}

			var_Resources_l = append(var_Resources_l, var_5x_mapped)
		}
		var_Resources_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Resources_l})
		properties["resources"] = var_Resources_mapped
	}

	var_Ids := eventSelector.Ids

	if var_Ids != nil {
		var var_Ids_mapped *structpb.Value

		var var_Ids_l []*structpb.Value
		for _, value := range var_Ids {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var var_5x_err error
			var_5x_mapped, var_5x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_5x)
			if var_5x_err != nil {
				panic(var_5x_err)
			}

			var_Ids_l = append(var_Ids_l, var_5x_mapped)
		}
		var_Ids_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Ids_l})
		properties["ids"] = var_Ids_mapped
	}

	var_Annotations := eventSelector.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped *structpb.Value

		var var_Annotations_st *structpb.Struct = new(structpb.Struct)
		var_Annotations_st.Fields = make(map[string]*structpb.Value)
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped *structpb.Value

			var var_1x_err error
			var_1x_mapped, var_1x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_1x)
			if var_1x_err != nil {
				panic(var_1x_err)
			}

			var_Annotations_st.Fields[key] = var_1x_mapped
		}
		var_Annotations_mapped = structpb.NewStructValue(var_Annotations_st)
		properties["annotations"] = var_Annotations_mapped
	}
	return properties
}

func (m *EventSelectorMapper) FromProperties(properties map[string]*structpb.Value) *EventSelector {
	var s = m.New()
	if properties["actions"] != nil && properties["actions"].AsInterface() != nil {

		var_Actions := properties["actions"]
		var_Actions_mapped := []EventAction{}
		for _, v := range var_Actions.GetListValue().Values {

			var_4x := v
			var_4x_mapped := (EventAction)(var_4x.GetStringValue())

			var_Actions_mapped = append(var_Actions_mapped, var_4x_mapped)
		}

		s.Actions = var_Actions_mapped
	}
	if properties["recordSelector"] != nil && properties["recordSelector"].AsInterface() != nil {

		var_RecordSelector := properties["recordSelector"]
		var mappedValue = ExtensionBooleanExpressionMapperInstance.FromProperties(var_RecordSelector.GetStructValue().Fields)

		var_RecordSelector_mapped := mappedValue

		s.RecordSelector = var_RecordSelector_mapped
	}
	if properties["namespaces"] != nil && properties["namespaces"].AsInterface() != nil {

		var_Namespaces := properties["namespaces"]
		var_Namespaces_mapped := []string{}
		for _, v := range var_Namespaces.GetListValue().Values {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_Namespaces_mapped = append(var_Namespaces_mapped, var_4x_mapped)
		}

		s.Namespaces = var_Namespaces_mapped
	}
	if properties["resources"] != nil && properties["resources"].AsInterface() != nil {

		var_Resources := properties["resources"]
		var_Resources_mapped := []string{}
		for _, v := range var_Resources.GetListValue().Values {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_Resources_mapped = append(var_Resources_mapped, var_4x_mapped)
		}

		s.Resources = var_Resources_mapped
	}
	if properties["ids"] != nil && properties["ids"].AsInterface() != nil {

		var_Ids := properties["ids"]
		var_Ids_mapped := []string{}
		for _, v := range var_Ids.GetListValue().Values {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_Ids_mapped = append(var_Ids_mapped, var_4x_mapped)
		}

		s.Ids = var_Ids_mapped
	}
	if properties["annotations"] != nil && properties["annotations"].AsInterface() != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.GetStructValue().Fields {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	return s
}

type RecordSearchParamsMapper struct {
}

func NewRecordSearchParamsMapper() *RecordSearchParamsMapper {
	return &RecordSearchParamsMapper{}
}

var RecordSearchParamsMapperInstance = NewRecordSearchParamsMapper()

func (m *RecordSearchParamsMapper) New() *RecordSearchParams {
	return &RecordSearchParams{}
}

func (m *RecordSearchParamsMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *RecordSearchParamsMapper) ToProperties(recordSearchParams *RecordSearchParams) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Query := recordSearchParams.Query

	if var_Query != nil {
		var var_Query_mapped *structpb.Value

		var_Query_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ExtensionBooleanExpressionMapperInstance.ToProperties(var_Query)})
		properties["query"] = var_Query_mapped
	}

	var_Limit := recordSearchParams.Limit

	if var_Limit != nil {
		var var_Limit_mapped *structpb.Value

		var var_Limit_err error
		var_Limit_mapped, var_Limit_err = types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(*var_Limit)
		if var_Limit_err != nil {
			panic(var_Limit_err)
		}
		properties["limit"] = var_Limit_mapped
	}

	var_Offset := recordSearchParams.Offset

	if var_Offset != nil {
		var var_Offset_mapped *structpb.Value

		var var_Offset_err error
		var_Offset_mapped, var_Offset_err = types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(*var_Offset)
		if var_Offset_err != nil {
			panic(var_Offset_err)
		}
		properties["offset"] = var_Offset_mapped
	}

	var_ResolveReferences := recordSearchParams.ResolveReferences

	if var_ResolveReferences != nil {
		var var_ResolveReferences_mapped *structpb.Value

		var var_ResolveReferences_l []*structpb.Value
		for _, value := range var_ResolveReferences {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var var_5x_err error
			var_5x_mapped, var_5x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_5x)
			if var_5x_err != nil {
				panic(var_5x_err)
			}

			var_ResolveReferences_l = append(var_ResolveReferences_l, var_5x_mapped)
		}
		var_ResolveReferences_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_ResolveReferences_l})
		properties["resolveReferences"] = var_ResolveReferences_mapped
	}
	return properties
}

func (m *RecordSearchParamsMapper) FromProperties(properties map[string]*structpb.Value) *RecordSearchParams {
	var s = m.New()
	if properties["query"] != nil && properties["query"].AsInterface() != nil {

		var_Query := properties["query"]
		var mappedValue = ExtensionBooleanExpressionMapperInstance.FromProperties(var_Query.GetStructValue().Fields)

		var_Query_mapped := mappedValue

		s.Query = var_Query_mapped
	}
	if properties["limit"] != nil && properties["limit"].AsInterface() != nil {

		var_Limit := properties["limit"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Limit)

		if err != nil {
			panic(err)
		}

		var_Limit_mapped := new(int32)
		*var_Limit_mapped = val.(int32)

		s.Limit = var_Limit_mapped
	}
	if properties["offset"] != nil && properties["offset"].AsInterface() != nil {

		var_Offset := properties["offset"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Offset)

		if err != nil {
			panic(err)
		}

		var_Offset_mapped := new(int32)
		*var_Offset_mapped = val.(int32)

		s.Offset = var_Offset_mapped
	}
	if properties["resolveReferences"] != nil && properties["resolveReferences"].AsInterface() != nil {

		var_ResolveReferences := properties["resolveReferences"]
		var_ResolveReferences_mapped := []string{}
		for _, v := range var_ResolveReferences.GetListValue().Values {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_ResolveReferences_mapped = append(var_ResolveReferences_mapped, var_4x_mapped)
		}

		s.ResolveReferences = var_ResolveReferences_mapped
	}
	return s
}

type EventMapper struct {
}

func NewEventMapper() *EventMapper {
	return &EventMapper{}
}

var EventMapperInstance = NewEventMapper()

func (m *EventMapper) New() *Event {
	return &Event{}
}

func (m *EventMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *EventMapper) ToProperties(event *Event) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Id := event.Id

	var var_Id_mapped *structpb.Value

	var var_Id_err error
	var_Id_mapped, var_Id_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Id)
	if var_Id_err != nil {
		panic(var_Id_err)
	}
	properties["id"] = var_Id_mapped

	var_Action := event.Action

	var var_Action_mapped *structpb.Value

	var var_Action_err error
	var_Action_mapped, var_Action_err = types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(string(var_Action))
	if var_Action_err != nil {
		panic(var_Action_err)
	}
	properties["action"] = var_Action_mapped

	var_RecordSearchParams := event.RecordSearchParams

	if var_RecordSearchParams != nil {
		var var_RecordSearchParams_mapped *structpb.Value

		var_RecordSearchParams_mapped = structpb.NewStructValue(&structpb.Struct{Fields: RecordSearchParamsMapperInstance.ToProperties(var_RecordSearchParams)})
		properties["recordSearchParams"] = var_RecordSearchParams_mapped
	}

	var_ActionSummary := event.ActionSummary

	if var_ActionSummary != nil {
		var var_ActionSummary_mapped *structpb.Value

		var var_ActionSummary_err error
		var_ActionSummary_mapped, var_ActionSummary_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_ActionSummary)
		if var_ActionSummary_err != nil {
			panic(var_ActionSummary_err)
		}
		properties["actionSummary"] = var_ActionSummary_mapped
	}

	var_ActionDescription := event.ActionDescription

	if var_ActionDescription != nil {
		var var_ActionDescription_mapped *structpb.Value

		var var_ActionDescription_err error
		var_ActionDescription_mapped, var_ActionDescription_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_ActionDescription)
		if var_ActionDescription_err != nil {
			panic(var_ActionDescription_err)
		}
		properties["actionDescription"] = var_ActionDescription_mapped
	}

	var_Resource := event.Resource

	if var_Resource != nil {
		var var_Resource_mapped *structpb.Value

		var_Resource_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ResourceMapperInstance.ToProperties(var_Resource)})
		properties["resource"] = var_Resource_mapped
	}

	var_Records := event.Records

	if var_Records != nil {
		var var_Records_mapped *structpb.Value

		var var_Records_l []*structpb.Value
		for _, value := range var_Records {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var_5x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: RecordMapperInstance.ToProperties(var_5x)})

			var_Records_l = append(var_Records_l, var_5x_mapped)
		}
		var_Records_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Records_l})
		properties["records"] = var_Records_mapped
	}

	var_Finalizes := event.Finalizes

	if var_Finalizes != nil {
		var var_Finalizes_mapped *structpb.Value

		var var_Finalizes_err error
		var_Finalizes_mapped, var_Finalizes_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(*var_Finalizes)
		if var_Finalizes_err != nil {
			panic(var_Finalizes_err)
		}
		properties["finalizes"] = var_Finalizes_mapped
	}

	var_Sync := event.Sync

	if var_Sync != nil {
		var var_Sync_mapped *structpb.Value

		var var_Sync_err error
		var_Sync_mapped, var_Sync_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(*var_Sync)
		if var_Sync_err != nil {
			panic(var_Sync_err)
		}
		properties["sync"] = var_Sync_mapped
	}

	var_Time := event.Time

	if var_Time != nil {
		var var_Time_mapped *structpb.Value

		var var_Time_err error
		var_Time_mapped, var_Time_err = types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(*var_Time)
		if var_Time_err != nil {
			panic(var_Time_err)
		}
		properties["time"] = var_Time_mapped
	}

	var_Total := event.Total

	if var_Total != nil {
		var var_Total_mapped *structpb.Value

		var var_Total_err error
		var_Total_mapped, var_Total_err = types.ByResourcePropertyType(model.ResourceProperty_INT64).Pack(*var_Total)
		if var_Total_err != nil {
			panic(var_Total_err)
		}
		properties["total"] = var_Total_mapped
	}

	var_ActionName := event.ActionName

	if var_ActionName != nil {
		var var_ActionName_mapped *structpb.Value

		var var_ActionName_err error
		var_ActionName_mapped, var_ActionName_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_ActionName)
		if var_ActionName_err != nil {
			panic(var_ActionName_err)
		}
		properties["actionName"] = var_ActionName_mapped
	}

	var_Input := event.Input

	if var_Input != nil {
		var var_Input_mapped *structpb.Value

		var var_Input_err error
		var_Input_mapped, var_Input_err = types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_Input)
		if var_Input_err != nil {
			panic(var_Input_err)
		}
		properties["input"] = var_Input_mapped
	}

	var_Output := event.Output

	if var_Output != nil {
		var var_Output_mapped *structpb.Value

		var var_Output_err error
		var_Output_mapped, var_Output_err = types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_Output)
		if var_Output_err != nil {
			panic(var_Output_err)
		}
		properties["output"] = var_Output_mapped
	}

	var_Annotations := event.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped *structpb.Value

		var var_Annotations_st *structpb.Struct = new(structpb.Struct)
		var_Annotations_st.Fields = make(map[string]*structpb.Value)
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped *structpb.Value

			var var_1x_err error
			var_1x_mapped, var_1x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_1x)
			if var_1x_err != nil {
				panic(var_1x_err)
			}

			var_Annotations_st.Fields[key] = var_1x_mapped
		}
		var_Annotations_mapped = structpb.NewStructValue(var_Annotations_st)
		properties["annotations"] = var_Annotations_mapped
	}

	var_Error := event.Error

	if var_Error != nil {
		var var_Error_mapped *structpb.Value

		var_Error_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ErrorMapperInstance.ToProperties(var_Error)})
		properties["error"] = var_Error_mapped
	}
	return properties
}

func (m *EventMapper) FromProperties(properties map[string]*structpb.Value) *Event {
	var s = m.New()
	if properties["id"] != nil && properties["id"].AsInterface() != nil {

		var_Id := properties["id"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Id)

		if err != nil {
			panic(err)
		}

		var_Id_mapped := val.(string)

		s.Id = var_Id_mapped
	}
	if properties["action"] != nil && properties["action"].AsInterface() != nil {

		var_Action := properties["action"]
		var_Action_mapped := (ExtensionAction)(var_Action.GetStringValue())

		s.Action = var_Action_mapped
	}
	if properties["recordSearchParams"] != nil && properties["recordSearchParams"].AsInterface() != nil {

		var_RecordSearchParams := properties["recordSearchParams"]
		var mappedValue = RecordSearchParamsMapperInstance.FromProperties(var_RecordSearchParams.GetStructValue().Fields)

		var_RecordSearchParams_mapped := mappedValue

		s.RecordSearchParams = var_RecordSearchParams_mapped
	}
	if properties["actionSummary"] != nil && properties["actionSummary"].AsInterface() != nil {

		var_ActionSummary := properties["actionSummary"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_ActionSummary)

		if err != nil {
			panic(err)
		}

		var_ActionSummary_mapped := new(string)
		*var_ActionSummary_mapped = val.(string)

		s.ActionSummary = var_ActionSummary_mapped
	}
	if properties["actionDescription"] != nil && properties["actionDescription"].AsInterface() != nil {

		var_ActionDescription := properties["actionDescription"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_ActionDescription)

		if err != nil {
			panic(err)
		}

		var_ActionDescription_mapped := new(string)
		*var_ActionDescription_mapped = val.(string)

		s.ActionDescription = var_ActionDescription_mapped
	}
	if properties["resource"] != nil && properties["resource"].AsInterface() != nil {

		var_Resource := properties["resource"]
		var_Resource_mapped := ResourceMapperInstance.FromProperties(var_Resource.GetStructValue().Fields)

		s.Resource = var_Resource_mapped
	}
	if properties["records"] != nil && properties["records"].AsInterface() != nil {

		var_Records := properties["records"]
		var_Records_mapped := []*Record{}
		for _, v := range var_Records.GetListValue().Values {

			var_4x := v
			var_4x_mapped := RecordMapperInstance.FromProperties(var_4x.GetStructValue().Fields)

			var_Records_mapped = append(var_Records_mapped, var_4x_mapped)
		}

		s.Records = var_Records_mapped
	}
	if properties["finalizes"] != nil && properties["finalizes"].AsInterface() != nil {

		var_Finalizes := properties["finalizes"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Finalizes)

		if err != nil {
			panic(err)
		}

		var_Finalizes_mapped := new(bool)
		*var_Finalizes_mapped = val.(bool)

		s.Finalizes = var_Finalizes_mapped
	}
	if properties["sync"] != nil && properties["sync"].AsInterface() != nil {

		var_Sync := properties["sync"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Sync)

		if err != nil {
			panic(err)
		}

		var_Sync_mapped := new(bool)
		*var_Sync_mapped = val.(bool)

		s.Sync = var_Sync_mapped
	}
	if properties["time"] != nil && properties["time"].AsInterface() != nil {

		var_Time := properties["time"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_Time)

		if err != nil {
			panic(err)
		}

		var_Time_mapped := new(time.Time)
		*var_Time_mapped = val.(time.Time)

		s.Time = var_Time_mapped
	}
	if properties["total"] != nil && properties["total"].AsInterface() != nil {

		var_Total := properties["total"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT64).UnPack(var_Total)

		if err != nil {
			panic(err)
		}

		var_Total_mapped := new(int64)
		*var_Total_mapped = val.(int64)

		s.Total = var_Total_mapped
	}
	if properties["actionName"] != nil && properties["actionName"].AsInterface() != nil {

		var_ActionName := properties["actionName"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_ActionName)

		if err != nil {
			panic(err)
		}

		var_ActionName_mapped := new(string)
		*var_ActionName_mapped = val.(string)

		s.ActionName = var_ActionName_mapped
	}
	if properties["input"] != nil && properties["input"].AsInterface() != nil {

		var_Input := properties["input"]
		var_Input_mapped := new(interface{})
		*var_Input_mapped = unstructured.FromValue(var_Input)

		s.Input = var_Input_mapped
	}
	if properties["output"] != nil && properties["output"].AsInterface() != nil {

		var_Output := properties["output"]
		var_Output_mapped := new(interface{})
		*var_Output_mapped = unstructured.FromValue(var_Output)

		s.Output = var_Output_mapped
	}
	if properties["annotations"] != nil && properties["annotations"].AsInterface() != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.GetStructValue().Fields {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	if properties["error"] != nil && properties["error"].AsInterface() != nil {

		var_Error := properties["error"]
		var mappedValue = ErrorMapperInstance.FromProperties(var_Error.GetStructValue().Fields)

		var_Error_mapped := mappedValue

		s.Error = var_Error_mapped
	}
	return s
}

type ErrorFieldMapper struct {
}

func NewErrorFieldMapper() *ErrorFieldMapper {
	return &ErrorFieldMapper{}
}

var ErrorFieldMapperInstance = NewErrorFieldMapper()

func (m *ErrorFieldMapper) New() *ErrorField {
	return &ErrorField{}
}

func (m *ErrorFieldMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ErrorFieldMapper) ToProperties(errorField *ErrorField) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_RecordId := errorField.RecordId

	if var_RecordId != nil {
		var var_RecordId_mapped *structpb.Value

		var var_RecordId_err error
		var_RecordId_mapped, var_RecordId_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_RecordId)
		if var_RecordId_err != nil {
			panic(var_RecordId_err)
		}
		properties["recordId"] = var_RecordId_mapped
	}

	var_Property := errorField.Property

	if var_Property != nil {
		var var_Property_mapped *structpb.Value

		var var_Property_err error
		var_Property_mapped, var_Property_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Property)
		if var_Property_err != nil {
			panic(var_Property_err)
		}
		properties["property"] = var_Property_mapped
	}

	var_Message := errorField.Message

	if var_Message != nil {
		var var_Message_mapped *structpb.Value

		var var_Message_err error
		var_Message_mapped, var_Message_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Message)
		if var_Message_err != nil {
			panic(var_Message_err)
		}
		properties["message"] = var_Message_mapped
	}

	var_Value := errorField.Value

	if var_Value != nil {
		var var_Value_mapped *structpb.Value

		var var_Value_err error
		var_Value_mapped, var_Value_err = types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_Value)
		if var_Value_err != nil {
			panic(var_Value_err)
		}
		properties["value"] = var_Value_mapped
	}
	return properties
}

func (m *ErrorFieldMapper) FromProperties(properties map[string]*structpb.Value) *ErrorField {
	var s = m.New()
	if properties["recordId"] != nil && properties["recordId"].AsInterface() != nil {

		var_RecordId := properties["recordId"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_RecordId)

		if err != nil {
			panic(err)
		}

		var_RecordId_mapped := new(string)
		*var_RecordId_mapped = val.(string)

		s.RecordId = var_RecordId_mapped
	}
	if properties["property"] != nil && properties["property"].AsInterface() != nil {

		var_Property := properties["property"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Property)

		if err != nil {
			panic(err)
		}

		var_Property_mapped := new(string)
		*var_Property_mapped = val.(string)

		s.Property = var_Property_mapped
	}
	if properties["message"] != nil && properties["message"].AsInterface() != nil {

		var_Message := properties["message"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Message)

		if err != nil {
			panic(err)
		}

		var_Message_mapped := new(string)
		*var_Message_mapped = val.(string)

		s.Message = var_Message_mapped
	}
	if properties["value"] != nil && properties["value"].AsInterface() != nil {

		var_Value := properties["value"]
		var_Value_mapped := new(interface{})
		*var_Value_mapped = unstructured.FromValue(var_Value)

		s.Value = var_Value_mapped
	}
	return s
}

type ErrorMapper struct {
}

func NewErrorMapper() *ErrorMapper {
	return &ErrorMapper{}
}

var ErrorMapperInstance = NewErrorMapper()

func (m *ErrorMapper) New() *Error {
	return &Error{}
}

func (m *ErrorMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ErrorMapper) ToProperties(error_ *Error) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Code := error_.Code

	if var_Code != nil {
		var var_Code_mapped *structpb.Value

		var var_Code_err error
		var_Code_mapped, var_Code_err = types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(string(*var_Code))
		if var_Code_err != nil {
			panic(var_Code_err)
		}
		properties["code"] = var_Code_mapped
	}

	var_Message := error_.Message

	if var_Message != nil {
		var var_Message_mapped *structpb.Value

		var var_Message_err error
		var_Message_mapped, var_Message_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Message)
		if var_Message_err != nil {
			panic(var_Message_err)
		}
		properties["message"] = var_Message_mapped
	}

	var_Fields := error_.Fields

	if var_Fields != nil {
		var var_Fields_mapped *structpb.Value

		var var_Fields_l []*structpb.Value
		for _, value := range var_Fields {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var_5x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ErrorFieldMapperInstance.ToProperties(&var_5x)})

			var_Fields_l = append(var_Fields_l, var_5x_mapped)
		}
		var_Fields_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Fields_l})
		properties["fields"] = var_Fields_mapped
	}
	return properties
}

func (m *ErrorMapper) FromProperties(properties map[string]*structpb.Value) *Error {
	var s = m.New()
	if properties["code"] != nil && properties["code"].AsInterface() != nil {

		var_Code := properties["code"]
		var_Code_mapped := new(ExtensionCode)
		*var_Code_mapped = (ExtensionCode)(var_Code.GetStringValue())

		s.Code = var_Code_mapped
	}
	if properties["message"] != nil && properties["message"].AsInterface() != nil {

		var_Message := properties["message"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Message)

		if err != nil {
			panic(err)
		}

		var_Message_mapped := new(string)
		*var_Message_mapped = val.(string)

		s.Message = var_Message_mapped
	}
	if properties["fields"] != nil && properties["fields"].AsInterface() != nil {

		var_Fields := properties["fields"]
		var_Fields_mapped := []ErrorField{}
		for _, v := range var_Fields.GetListValue().Values {

			var_4x := v
			var mappedValue = ErrorFieldMapperInstance.FromProperties(var_4x.GetStructValue().Fields)

			var_4x_mapped := *mappedValue

			var_Fields_mapped = append(var_Fields_mapped, var_4x_mapped)
		}

		s.Fields = var_Fields_mapped
	}
	return s
}
