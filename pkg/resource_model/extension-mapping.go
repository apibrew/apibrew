// Code generated by apbr generate. DO NOT EDIT.
// versions:
// 	apbr generate v1.2

//go:build !codeanalysis

package resource_model

import (
	"github.com/apibrew/apibrew/pkg/abs"
	"github.com/apibrew/apibrew/pkg/model"
	"github.com/apibrew/apibrew/pkg/types"
)

import "github.com/google/uuid"
import "time"

type ExtensionMapper struct {
}

func NewExtensionMapper() *ExtensionMapper {
	return &ExtensionMapper{}
}

var ExtensionMapperInstance = NewExtensionMapper()

func (m *ExtensionMapper) New() *Extension {
	return &Extension{}
}

func (m *ExtensionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionMapper) ToRecord(extension *Extension) abs.RecordLike {
	return abs.NewRecordLikeWithProperties(m.ToProperties(extension))
}

func (m *ExtensionMapper) FromRecord(record abs.RecordLike) *Extension {
	return m.FromProperties(record.MapCopy())
}

func (m *ExtensionMapper) ToProperties(extension *Extension) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Id := extension.Id

	if var_Id != nil {
		var var_Id_mapped interface{}

		var_Id_mapped = *var_Id

		var_Id_packed, err := types.ByResourcePropertyType(model.ResourceProperty_UUID).Pack(var_Id_mapped)

		if err != nil {
			panic(err)
		}

		properties["id"] = var_Id_packed
	}

	var_Version := extension.Version

	var var_Version_mapped interface{}

	var_Version_mapped = var_Version
	var_Version_packed, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Version_mapped)

	if err != nil {
		panic(err)
	}

	properties["version"] = var_Version_packed

	var_AuditData := extension.AuditData

	if var_AuditData != nil {
		var var_AuditData_mapped interface{}

		var_AuditData_mapped = ExtensionAuditDataMapperInstance.ToProperties(var_AuditData)

		var_AuditData_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_AuditData_mapped)

		if err != nil {
			panic(err)
		}

		properties["auditData"] = var_AuditData_packed
	}

	var_Name := extension.Name

	var var_Name_mapped interface{}

	var_Name_mapped = var_Name
	var_Name_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Name_mapped)

	if err != nil {
		panic(err)
	}

	properties["name"] = var_Name_packed

	var_Description := extension.Description

	if var_Description != nil {
		var var_Description_mapped interface{}

		var_Description_mapped = *var_Description

		var_Description_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Description_mapped)

		if err != nil {
			panic(err)
		}

		properties["description"] = var_Description_packed
	}

	var_Selector := extension.Selector

	if var_Selector != nil {
		var var_Selector_mapped interface{}

		var_Selector_mapped = EventSelectorMapperInstance.ToProperties(var_Selector)

		var_Selector_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Selector_mapped)

		if err != nil {
			panic(err)
		}

		properties["selector"] = var_Selector_packed
	}

	var_Order := extension.Order

	var var_Order_mapped interface{}

	var_Order_mapped = var_Order
	var_Order_packed, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Order_mapped)

	if err != nil {
		panic(err)
	}

	properties["order"] = var_Order_packed

	var_Finalizes := extension.Finalizes

	var var_Finalizes_mapped interface{}

	var_Finalizes_mapped = var_Finalizes
	var_Finalizes_packed, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Finalizes_mapped)

	if err != nil {
		panic(err)
	}

	properties["finalizes"] = var_Finalizes_packed

	var_Sync := extension.Sync

	var var_Sync_mapped interface{}

	var_Sync_mapped = var_Sync
	var_Sync_packed, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Sync_mapped)

	if err != nil {
		panic(err)
	}

	properties["sync"] = var_Sync_packed

	var_Responds := extension.Responds

	var var_Responds_mapped interface{}

	var_Responds_mapped = var_Responds
	var_Responds_packed, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Responds_mapped)

	if err != nil {
		panic(err)
	}

	properties["responds"] = var_Responds_packed

	var_Call := extension.Call

	var var_Call_mapped interface{}

	var_Call_mapped = ExternalCallMapperInstance.ToProperties(&var_Call)
	var_Call_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Call_mapped)

	if err != nil {
		panic(err)
	}

	properties["call"] = var_Call_packed

	var_Annotations := extension.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped interface{}

		var var_Annotations_st = make(map[string]interface{})
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped interface{}

			var_1x_mapped = var_1x

			var_Annotations_st[key] = var_1x_mapped
		}
		var_Annotations_mapped = var_Annotations_st

		var_Annotations_packed, err := types.ByResourcePropertyType(model.ResourceProperty_MAP).Pack(var_Annotations_mapped)

		if err != nil {
			panic(err)
		}

		properties["annotations"] = var_Annotations_packed
	}
	return properties
}

func (m *ExtensionMapper) FromProperties(properties map[string]interface{}) *Extension {
	var s = m.New()
	if properties["id"] != nil {

		var_Id := properties["id"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_UUID).UnPack(var_Id)

		if err != nil {
			panic(err)
		}

		var_Id_mapped := new(uuid.UUID)
		*var_Id_mapped = val.(uuid.UUID)

		s.Id = var_Id_mapped
	}
	if properties["version"] != nil {

		var_Version := properties["version"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Version)

		if err != nil {
			panic(err)
		}

		var_Version_mapped := val.(int32)

		s.Version = var_Version_mapped
	}
	if properties["auditData"] != nil {

		var_AuditData := properties["auditData"]
		var mappedValue = ExtensionAuditDataMapperInstance.FromProperties(var_AuditData.(map[string]interface{}))

		var_AuditData_mapped := mappedValue

		s.AuditData = var_AuditData_mapped
	}
	if properties["name"] != nil {

		var_Name := properties["name"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Name)

		if err != nil {
			panic(err)
		}

		var_Name_mapped := val.(string)

		s.Name = var_Name_mapped
	}
	if properties["description"] != nil {

		var_Description := properties["description"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Description)

		if err != nil {
			panic(err)
		}

		var_Description_mapped := new(string)
		*var_Description_mapped = val.(string)

		s.Description = var_Description_mapped
	}
	if properties["selector"] != nil {

		var_Selector := properties["selector"]
		var mappedValue = EventSelectorMapperInstance.FromProperties(var_Selector.(map[string]interface{}))

		var_Selector_mapped := mappedValue

		s.Selector = var_Selector_mapped
	}
	if properties["order"] != nil {

		var_Order := properties["order"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Order)

		if err != nil {
			panic(err)
		}

		var_Order_mapped := val.(int32)

		s.Order = var_Order_mapped
	}
	if properties["finalizes"] != nil {

		var_Finalizes := properties["finalizes"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Finalizes)

		if err != nil {
			panic(err)
		}

		var_Finalizes_mapped := val.(bool)

		s.Finalizes = var_Finalizes_mapped
	}
	if properties["sync"] != nil {

		var_Sync := properties["sync"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Sync)

		if err != nil {
			panic(err)
		}

		var_Sync_mapped := val.(bool)

		s.Sync = var_Sync_mapped
	}
	if properties["responds"] != nil {

		var_Responds := properties["responds"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Responds)

		if err != nil {
			panic(err)
		}

		var_Responds_mapped := val.(bool)

		s.Responds = var_Responds_mapped
	}
	if properties["call"] != nil {

		var_Call := properties["call"]
		var mappedValue = ExternalCallMapperInstance.FromProperties(var_Call.(map[string]interface{}))

		var_Call_mapped := *mappedValue

		s.Call = var_Call_mapped
	}
	if properties["annotations"] != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.(map[string]interface{}) {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	return s
}

type BooleanExpressionMapper struct {
}

func NewBooleanExpressionMapper() *BooleanExpressionMapper {
	return &BooleanExpressionMapper{}
}

var BooleanExpressionMapperInstance = NewBooleanExpressionMapper()

func (m *BooleanExpressionMapper) New() *BooleanExpression {
	return &BooleanExpression{}
}

func (m *BooleanExpressionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *BooleanExpressionMapper) ToProperties(booleanExpression *BooleanExpression) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_And := booleanExpression.And

	if var_And != nil {
		var var_And_mapped interface{}

		var var_And_l []interface{}
		for _, value := range var_And {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = BooleanExpressionMapperInstance.ToProperties(&var_5x)

			var_And_l = append(var_And_l, var_5x_mapped)
		}
		var_And_mapped = var_And_l

		var_And_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_And_mapped)

		if err != nil {
			panic(err)
		}

		properties["and"] = var_And_packed
	}

	var_Or := booleanExpression.Or

	if var_Or != nil {
		var var_Or_mapped interface{}

		var var_Or_l []interface{}
		for _, value := range var_Or {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = BooleanExpressionMapperInstance.ToProperties(&var_5x)

			var_Or_l = append(var_Or_l, var_5x_mapped)
		}
		var_Or_mapped = var_Or_l

		var_Or_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_Or_mapped)

		if err != nil {
			panic(err)
		}

		properties["or"] = var_Or_packed
	}

	var_Not := booleanExpression.Not

	if var_Not != nil {
		var var_Not_mapped interface{}

		var_Not_mapped = BooleanExpressionMapperInstance.ToProperties(var_Not)

		var_Not_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Not_mapped)

		if err != nil {
			panic(err)
		}

		properties["not"] = var_Not_packed
	}

	var_Equal := booleanExpression.Equal

	if var_Equal != nil {
		var var_Equal_mapped interface{}

		var_Equal_mapped = PairExpressionMapperInstance.ToProperties(var_Equal)

		var_Equal_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Equal_mapped)

		if err != nil {
			panic(err)
		}

		properties["equal"] = var_Equal_packed
	}

	var_LessThan := booleanExpression.LessThan

	if var_LessThan != nil {
		var var_LessThan_mapped interface{}

		var_LessThan_mapped = PairExpressionMapperInstance.ToProperties(var_LessThan)

		var_LessThan_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_LessThan_mapped)

		if err != nil {
			panic(err)
		}

		properties["lessThan"] = var_LessThan_packed
	}

	var_GreaterThan := booleanExpression.GreaterThan

	if var_GreaterThan != nil {
		var var_GreaterThan_mapped interface{}

		var_GreaterThan_mapped = PairExpressionMapperInstance.ToProperties(var_GreaterThan)

		var_GreaterThan_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_GreaterThan_mapped)

		if err != nil {
			panic(err)
		}

		properties["greaterThan"] = var_GreaterThan_packed
	}

	var_LessThanOrEqual := booleanExpression.LessThanOrEqual

	if var_LessThanOrEqual != nil {
		var var_LessThanOrEqual_mapped interface{}

		var_LessThanOrEqual_mapped = PairExpressionMapperInstance.ToProperties(var_LessThanOrEqual)

		var_LessThanOrEqual_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_LessThanOrEqual_mapped)

		if err != nil {
			panic(err)
		}

		properties["lessThanOrEqual"] = var_LessThanOrEqual_packed
	}

	var_GreaterThanOrEqual := booleanExpression.GreaterThanOrEqual

	if var_GreaterThanOrEqual != nil {
		var var_GreaterThanOrEqual_mapped interface{}

		var_GreaterThanOrEqual_mapped = PairExpressionMapperInstance.ToProperties(var_GreaterThanOrEqual)

		var_GreaterThanOrEqual_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_GreaterThanOrEqual_mapped)

		if err != nil {
			panic(err)
		}

		properties["greaterThanOrEqual"] = var_GreaterThanOrEqual_packed
	}

	var_In := booleanExpression.In

	if var_In != nil {
		var var_In_mapped interface{}

		var_In_mapped = PairExpressionMapperInstance.ToProperties(var_In)

		var_In_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_In_mapped)

		if err != nil {
			panic(err)
		}

		properties["in"] = var_In_packed
	}

	var_Like := booleanExpression.Like

	if var_Like != nil {
		var var_Like_mapped interface{}

		var_Like_mapped = PairExpressionMapperInstance.ToProperties(var_Like)

		var_Like_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Like_mapped)

		if err != nil {
			panic(err)
		}

		properties["like"] = var_Like_packed
	}

	var_Ilike := booleanExpression.Ilike

	if var_Ilike != nil {
		var var_Ilike_mapped interface{}

		var_Ilike_mapped = PairExpressionMapperInstance.ToProperties(var_Ilike)

		var_Ilike_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Ilike_mapped)

		if err != nil {
			panic(err)
		}

		properties["ilike"] = var_Ilike_packed
	}

	var_Regex := booleanExpression.Regex

	if var_Regex != nil {
		var var_Regex_mapped interface{}

		var_Regex_mapped = PairExpressionMapperInstance.ToProperties(var_Regex)

		var_Regex_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Regex_mapped)

		if err != nil {
			panic(err)
		}

		properties["regex"] = var_Regex_packed
	}

	var_IsNull := booleanExpression.IsNull

	if var_IsNull != nil {
		var var_IsNull_mapped interface{}

		var_IsNull_mapped = ExpressionMapperInstance.ToProperties(var_IsNull)

		var_IsNull_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_IsNull_mapped)

		if err != nil {
			panic(err)
		}

		properties["isNull"] = var_IsNull_packed
	}

	var_Filters := booleanExpression.Filters

	if var_Filters != nil {
		var var_Filters_mapped interface{}

		var var_Filters_st = make(map[string]interface{})
		for key, value := range var_Filters {

			var_1x := value
			var var_1x_mapped interface{}

			var_1x_mapped = var_1x

			var_Filters_st[key] = var_1x_mapped
		}
		var_Filters_mapped = var_Filters_st

		var_Filters_packed, err := types.ByResourcePropertyType(model.ResourceProperty_MAP).Pack(var_Filters_mapped)

		if err != nil {
			panic(err)
		}

		properties["filters"] = var_Filters_packed
	}
	return properties
}

func (m *BooleanExpressionMapper) FromProperties(properties map[string]interface{}) *BooleanExpression {
	var s = m.New()
	if properties["and"] != nil {

		var_And := properties["and"]
		var_And_mapped := []BooleanExpression{}
		for _, v := range var_And.([]interface{}) {

			var_4x := v
			var mappedValue = BooleanExpressionMapperInstance.FromProperties(var_4x.(map[string]interface{}))

			var_4x_mapped := *mappedValue

			var_And_mapped = append(var_And_mapped, var_4x_mapped)
		}

		s.And = var_And_mapped
	}
	if properties["or"] != nil {

		var_Or := properties["or"]
		var_Or_mapped := []BooleanExpression{}
		for _, v := range var_Or.([]interface{}) {

			var_4x := v
			var mappedValue = BooleanExpressionMapperInstance.FromProperties(var_4x.(map[string]interface{}))

			var_4x_mapped := *mappedValue

			var_Or_mapped = append(var_Or_mapped, var_4x_mapped)
		}

		s.Or = var_Or_mapped
	}
	if properties["not"] != nil {

		var_Not := properties["not"]
		var mappedValue = BooleanExpressionMapperInstance.FromProperties(var_Not.(map[string]interface{}))

		var_Not_mapped := mappedValue

		s.Not = var_Not_mapped
	}
	if properties["equal"] != nil {

		var_Equal := properties["equal"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_Equal.(map[string]interface{}))

		var_Equal_mapped := mappedValue

		s.Equal = var_Equal_mapped
	}
	if properties["lessThan"] != nil {

		var_LessThan := properties["lessThan"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_LessThan.(map[string]interface{}))

		var_LessThan_mapped := mappedValue

		s.LessThan = var_LessThan_mapped
	}
	if properties["greaterThan"] != nil {

		var_GreaterThan := properties["greaterThan"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_GreaterThan.(map[string]interface{}))

		var_GreaterThan_mapped := mappedValue

		s.GreaterThan = var_GreaterThan_mapped
	}
	if properties["lessThanOrEqual"] != nil {

		var_LessThanOrEqual := properties["lessThanOrEqual"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_LessThanOrEqual.(map[string]interface{}))

		var_LessThanOrEqual_mapped := mappedValue

		s.LessThanOrEqual = var_LessThanOrEqual_mapped
	}
	if properties["greaterThanOrEqual"] != nil {

		var_GreaterThanOrEqual := properties["greaterThanOrEqual"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_GreaterThanOrEqual.(map[string]interface{}))

		var_GreaterThanOrEqual_mapped := mappedValue

		s.GreaterThanOrEqual = var_GreaterThanOrEqual_mapped
	}
	if properties["in"] != nil {

		var_In := properties["in"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_In.(map[string]interface{}))

		var_In_mapped := mappedValue

		s.In = var_In_mapped
	}
	if properties["like"] != nil {

		var_Like := properties["like"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_Like.(map[string]interface{}))

		var_Like_mapped := mappedValue

		s.Like = var_Like_mapped
	}
	if properties["ilike"] != nil {

		var_Ilike := properties["ilike"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_Ilike.(map[string]interface{}))

		var_Ilike_mapped := mappedValue

		s.Ilike = var_Ilike_mapped
	}
	if properties["regex"] != nil {

		var_Regex := properties["regex"]
		var mappedValue = PairExpressionMapperInstance.FromProperties(var_Regex.(map[string]interface{}))

		var_Regex_mapped := mappedValue

		s.Regex = var_Regex_mapped
	}
	if properties["isNull"] != nil {

		var_IsNull := properties["isNull"]
		var mappedValue = ExpressionMapperInstance.FromProperties(var_IsNull.(map[string]interface{}))

		var_IsNull_mapped := mappedValue

		s.IsNull = var_IsNull_mapped
	}
	if properties["filters"] != nil {

		var_Filters := properties["filters"]
		var_Filters_mapped := make(map[string]interface{})
		for k, v := range var_Filters.(map[string]interface{}) {

			var_3x := v
			var_3x_mapped := var_3x

			var_Filters_mapped[k] = var_3x_mapped
		}

		s.Filters = var_Filters_mapped
	}
	return s
}

type PairExpressionMapper struct {
}

func NewPairExpressionMapper() *PairExpressionMapper {
	return &PairExpressionMapper{}
}

var PairExpressionMapperInstance = NewPairExpressionMapper()

func (m *PairExpressionMapper) New() *PairExpression {
	return &PairExpression{}
}

func (m *PairExpressionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *PairExpressionMapper) ToProperties(pairExpression *PairExpression) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Left := pairExpression.Left

	if var_Left != nil {
		var var_Left_mapped interface{}

		var_Left_mapped = ExpressionMapperInstance.ToProperties(var_Left)

		var_Left_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Left_mapped)

		if err != nil {
			panic(err)
		}

		properties["left"] = var_Left_packed
	}

	var_Right := pairExpression.Right

	if var_Right != nil {
		var var_Right_mapped interface{}

		var_Right_mapped = ExpressionMapperInstance.ToProperties(var_Right)

		var_Right_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Right_mapped)

		if err != nil {
			panic(err)
		}

		properties["right"] = var_Right_packed
	}
	return properties
}

func (m *PairExpressionMapper) FromProperties(properties map[string]interface{}) *PairExpression {
	var s = m.New()
	if properties["left"] != nil {

		var_Left := properties["left"]
		var mappedValue = ExpressionMapperInstance.FromProperties(var_Left.(map[string]interface{}))

		var_Left_mapped := mappedValue

		s.Left = var_Left_mapped
	}
	if properties["right"] != nil {

		var_Right := properties["right"]
		var mappedValue = ExpressionMapperInstance.FromProperties(var_Right.(map[string]interface{}))

		var_Right_mapped := mappedValue

		s.Right = var_Right_mapped
	}
	return s
}

type ExpressionMapper struct {
}

func NewExpressionMapper() *ExpressionMapper {
	return &ExpressionMapper{}
}

var ExpressionMapperInstance = NewExpressionMapper()

func (m *ExpressionMapper) New() *Expression {
	return &Expression{}
}

func (m *ExpressionMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExpressionMapper) ToProperties(expression *Expression) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Property := expression.Property

	if var_Property != nil {
		var var_Property_mapped interface{}

		var_Property_mapped = *var_Property

		var_Property_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Property_mapped)

		if err != nil {
			panic(err)
		}

		properties["property"] = var_Property_packed
	}

	var_Value := expression.Value

	if var_Value != nil {
		var var_Value_mapped interface{}

		var_Value_mapped = var_Value

		var_Value_packed, err := types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_Value_mapped)

		if err != nil {
			panic(err)
		}

		properties["value"] = var_Value_packed
	}
	return properties
}

func (m *ExpressionMapper) FromProperties(properties map[string]interface{}) *Expression {
	var s = m.New()
	if properties["property"] != nil {

		var_Property := properties["property"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Property)

		if err != nil {
			panic(err)
		}

		var_Property_mapped := new(string)
		*var_Property_mapped = val.(string)

		s.Property = var_Property_mapped
	}
	if properties["value"] != nil {

		var_Value := properties["value"]
		var_Value_mapped := new(interface{})
		*var_Value_mapped = var_Value

		s.Value = var_Value_mapped
	}
	return s
}

type ExtensionAuditDataMapper struct {
}

func NewExtensionAuditDataMapper() *ExtensionAuditDataMapper {
	return &ExtensionAuditDataMapper{}
}

var ExtensionAuditDataMapperInstance = NewExtensionAuditDataMapper()

func (m *ExtensionAuditDataMapper) New() *ExtensionAuditData {
	return &ExtensionAuditData{}
}

func (m *ExtensionAuditDataMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExtensionAuditDataMapper) ToProperties(extensionAuditData *ExtensionAuditData) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_CreatedBy := extensionAuditData.CreatedBy

	if var_CreatedBy != nil {
		var var_CreatedBy_mapped interface{}

		var_CreatedBy_mapped = *var_CreatedBy

		var_CreatedBy_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_CreatedBy_mapped)

		if err != nil {
			panic(err)
		}

		properties["createdBy"] = var_CreatedBy_packed
	}

	var_UpdatedBy := extensionAuditData.UpdatedBy

	if var_UpdatedBy != nil {
		var var_UpdatedBy_mapped interface{}

		var_UpdatedBy_mapped = *var_UpdatedBy

		var_UpdatedBy_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_UpdatedBy_mapped)

		if err != nil {
			panic(err)
		}

		properties["updatedBy"] = var_UpdatedBy_packed
	}

	var_CreatedOn := extensionAuditData.CreatedOn

	if var_CreatedOn != nil {
		var var_CreatedOn_mapped interface{}

		var_CreatedOn_mapped = *var_CreatedOn

		var_CreatedOn_packed, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(var_CreatedOn_mapped)

		if err != nil {
			panic(err)
		}

		properties["createdOn"] = var_CreatedOn_packed
	}

	var_UpdatedOn := extensionAuditData.UpdatedOn

	if var_UpdatedOn != nil {
		var var_UpdatedOn_mapped interface{}

		var_UpdatedOn_mapped = *var_UpdatedOn

		var_UpdatedOn_packed, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(var_UpdatedOn_mapped)

		if err != nil {
			panic(err)
		}

		properties["updatedOn"] = var_UpdatedOn_packed
	}
	return properties
}

func (m *ExtensionAuditDataMapper) FromProperties(properties map[string]interface{}) *ExtensionAuditData {
	var s = m.New()
	if properties["createdBy"] != nil {

		var_CreatedBy := properties["createdBy"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_CreatedBy)

		if err != nil {
			panic(err)
		}

		var_CreatedBy_mapped := new(string)
		*var_CreatedBy_mapped = val.(string)

		s.CreatedBy = var_CreatedBy_mapped
	}
	if properties["updatedBy"] != nil {

		var_UpdatedBy := properties["updatedBy"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_UpdatedBy)

		if err != nil {
			panic(err)
		}

		var_UpdatedBy_mapped := new(string)
		*var_UpdatedBy_mapped = val.(string)

		s.UpdatedBy = var_UpdatedBy_mapped
	}
	if properties["createdOn"] != nil {

		var_CreatedOn := properties["createdOn"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_CreatedOn)

		if err != nil {
			panic(err)
		}

		var_CreatedOn_mapped := new(time.Time)
		*var_CreatedOn_mapped = val.(time.Time)

		s.CreatedOn = var_CreatedOn_mapped
	}
	if properties["updatedOn"] != nil {

		var_UpdatedOn := properties["updatedOn"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_UpdatedOn)

		if err != nil {
			panic(err)
		}

		var_UpdatedOn_mapped := new(time.Time)
		*var_UpdatedOn_mapped = val.(time.Time)

		s.UpdatedOn = var_UpdatedOn_mapped
	}
	return s
}

type FunctionCallMapper struct {
}

func NewFunctionCallMapper() *FunctionCallMapper {
	return &FunctionCallMapper{}
}

var FunctionCallMapperInstance = NewFunctionCallMapper()

func (m *FunctionCallMapper) New() *FunctionCall {
	return &FunctionCall{}
}

func (m *FunctionCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *FunctionCallMapper) ToProperties(functionCall *FunctionCall) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Host := functionCall.Host

	var var_Host_mapped interface{}

	var_Host_mapped = var_Host
	var_Host_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Host_mapped)

	if err != nil {
		panic(err)
	}

	properties["host"] = var_Host_packed

	var_FunctionName := functionCall.FunctionName

	var var_FunctionName_mapped interface{}

	var_FunctionName_mapped = var_FunctionName
	var_FunctionName_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_FunctionName_mapped)

	if err != nil {
		panic(err)
	}

	properties["functionName"] = var_FunctionName_packed
	return properties
}

func (m *FunctionCallMapper) FromProperties(properties map[string]interface{}) *FunctionCall {
	var s = m.New()
	if properties["host"] != nil {

		var_Host := properties["host"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Host)

		if err != nil {
			panic(err)
		}

		var_Host_mapped := val.(string)

		s.Host = var_Host_mapped
	}
	if properties["functionName"] != nil {

		var_FunctionName := properties["functionName"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_FunctionName)

		if err != nil {
			panic(err)
		}

		var_FunctionName_mapped := val.(string)

		s.FunctionName = var_FunctionName_mapped
	}
	return s
}

type HttpCallMapper struct {
}

func NewHttpCallMapper() *HttpCallMapper {
	return &HttpCallMapper{}
}

var HttpCallMapperInstance = NewHttpCallMapper()

func (m *HttpCallMapper) New() *HttpCall {
	return &HttpCall{}
}

func (m *HttpCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *HttpCallMapper) ToProperties(httpCall *HttpCall) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Uri := httpCall.Uri

	var var_Uri_mapped interface{}

	var_Uri_mapped = var_Uri
	var_Uri_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Uri_mapped)

	if err != nil {
		panic(err)
	}

	properties["uri"] = var_Uri_packed

	var_Method := httpCall.Method

	var var_Method_mapped interface{}

	var_Method_mapped = var_Method
	var_Method_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Method_mapped)

	if err != nil {
		panic(err)
	}

	properties["method"] = var_Method_packed
	return properties
}

func (m *HttpCallMapper) FromProperties(properties map[string]interface{}) *HttpCall {
	var s = m.New()
	if properties["uri"] != nil {

		var_Uri := properties["uri"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Uri)

		if err != nil {
			panic(err)
		}

		var_Uri_mapped := val.(string)

		s.Uri = var_Uri_mapped
	}
	if properties["method"] != nil {

		var_Method := properties["method"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Method)

		if err != nil {
			panic(err)
		}

		var_Method_mapped := val.(string)

		s.Method = var_Method_mapped
	}
	return s
}

type ChannelCallMapper struct {
}

func NewChannelCallMapper() *ChannelCallMapper {
	return &ChannelCallMapper{}
}

var ChannelCallMapperInstance = NewChannelCallMapper()

func (m *ChannelCallMapper) New() *ChannelCall {
	return &ChannelCall{}
}

func (m *ChannelCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ChannelCallMapper) ToProperties(channelCall *ChannelCall) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_ChannelKey := channelCall.ChannelKey

	var var_ChannelKey_mapped interface{}

	var_ChannelKey_mapped = var_ChannelKey
	var_ChannelKey_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_ChannelKey_mapped)

	if err != nil {
		panic(err)
	}

	properties["channelKey"] = var_ChannelKey_packed
	return properties
}

func (m *ChannelCallMapper) FromProperties(properties map[string]interface{}) *ChannelCall {
	var s = m.New()
	if properties["channelKey"] != nil {

		var_ChannelKey := properties["channelKey"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_ChannelKey)

		if err != nil {
			panic(err)
		}

		var_ChannelKey_mapped := val.(string)

		s.ChannelKey = var_ChannelKey_mapped
	}
	return s
}

type ExternalCallMapper struct {
}

func NewExternalCallMapper() *ExternalCallMapper {
	return &ExternalCallMapper{}
}

var ExternalCallMapperInstance = NewExternalCallMapper()

func (m *ExternalCallMapper) New() *ExternalCall {
	return &ExternalCall{}
}

func (m *ExternalCallMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ExternalCallMapper) ToProperties(externalCall *ExternalCall) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_FunctionCall := externalCall.FunctionCall

	if var_FunctionCall != nil {
		var var_FunctionCall_mapped interface{}

		var_FunctionCall_mapped = FunctionCallMapperInstance.ToProperties(var_FunctionCall)

		var_FunctionCall_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_FunctionCall_mapped)

		if err != nil {
			panic(err)
		}

		properties["functionCall"] = var_FunctionCall_packed
	}

	var_HttpCall := externalCall.HttpCall

	if var_HttpCall != nil {
		var var_HttpCall_mapped interface{}

		var_HttpCall_mapped = HttpCallMapperInstance.ToProperties(var_HttpCall)

		var_HttpCall_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_HttpCall_mapped)

		if err != nil {
			panic(err)
		}

		properties["httpCall"] = var_HttpCall_packed
	}

	var_ChannelCall := externalCall.ChannelCall

	if var_ChannelCall != nil {
		var var_ChannelCall_mapped interface{}

		var_ChannelCall_mapped = ChannelCallMapperInstance.ToProperties(var_ChannelCall)

		var_ChannelCall_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_ChannelCall_mapped)

		if err != nil {
			panic(err)
		}

		properties["channelCall"] = var_ChannelCall_packed
	}
	return properties
}

func (m *ExternalCallMapper) FromProperties(properties map[string]interface{}) *ExternalCall {
	var s = m.New()
	if properties["functionCall"] != nil {

		var_FunctionCall := properties["functionCall"]
		var mappedValue = FunctionCallMapperInstance.FromProperties(var_FunctionCall.(map[string]interface{}))

		var_FunctionCall_mapped := mappedValue

		s.FunctionCall = var_FunctionCall_mapped
	}
	if properties["httpCall"] != nil {

		var_HttpCall := properties["httpCall"]
		var mappedValue = HttpCallMapperInstance.FromProperties(var_HttpCall.(map[string]interface{}))

		var_HttpCall_mapped := mappedValue

		s.HttpCall = var_HttpCall_mapped
	}
	if properties["channelCall"] != nil {

		var_ChannelCall := properties["channelCall"]
		var mappedValue = ChannelCallMapperInstance.FromProperties(var_ChannelCall.(map[string]interface{}))

		var_ChannelCall_mapped := mappedValue

		s.ChannelCall = var_ChannelCall_mapped
	}
	return s
}

type EventSelectorMapper struct {
}

func NewEventSelectorMapper() *EventSelectorMapper {
	return &EventSelectorMapper{}
}

var EventSelectorMapperInstance = NewEventSelectorMapper()

func (m *EventSelectorMapper) New() *EventSelector {
	return &EventSelector{}
}

func (m *EventSelectorMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *EventSelectorMapper) ToProperties(eventSelector *EventSelector) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Actions := eventSelector.Actions

	if var_Actions != nil {
		var var_Actions_mapped interface{}

		var var_Actions_l []interface{}
		for _, value := range var_Actions {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = string(var_5x)

			var_Actions_l = append(var_Actions_l, var_5x_mapped)
		}
		var_Actions_mapped = var_Actions_l

		var_Actions_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_Actions_mapped)

		if err != nil {
			panic(err)
		}

		properties["actions"] = var_Actions_packed
	}

	var_RecordSelector := eventSelector.RecordSelector

	if var_RecordSelector != nil {
		var var_RecordSelector_mapped interface{}

		var_RecordSelector_mapped = BooleanExpressionMapperInstance.ToProperties(var_RecordSelector)

		var_RecordSelector_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_RecordSelector_mapped)

		if err != nil {
			panic(err)
		}

		properties["recordSelector"] = var_RecordSelector_packed
	}

	var_Namespaces := eventSelector.Namespaces

	if var_Namespaces != nil {
		var var_Namespaces_mapped interface{}

		var var_Namespaces_l []interface{}
		for _, value := range var_Namespaces {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = var_5x

			var_Namespaces_l = append(var_Namespaces_l, var_5x_mapped)
		}
		var_Namespaces_mapped = var_Namespaces_l

		var_Namespaces_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_Namespaces_mapped)

		if err != nil {
			panic(err)
		}

		properties["namespaces"] = var_Namespaces_packed
	}

	var_Resources := eventSelector.Resources

	if var_Resources != nil {
		var var_Resources_mapped interface{}

		var var_Resources_l []interface{}
		for _, value := range var_Resources {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = var_5x

			var_Resources_l = append(var_Resources_l, var_5x_mapped)
		}
		var_Resources_mapped = var_Resources_l

		var_Resources_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_Resources_mapped)

		if err != nil {
			panic(err)
		}

		properties["resources"] = var_Resources_packed
	}

	var_Ids := eventSelector.Ids

	if var_Ids != nil {
		var var_Ids_mapped interface{}

		var var_Ids_l []interface{}
		for _, value := range var_Ids {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = var_5x

			var_Ids_l = append(var_Ids_l, var_5x_mapped)
		}
		var_Ids_mapped = var_Ids_l

		var_Ids_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_Ids_mapped)

		if err != nil {
			panic(err)
		}

		properties["ids"] = var_Ids_packed
	}

	var_Annotations := eventSelector.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped interface{}

		var var_Annotations_st = make(map[string]interface{})
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped interface{}

			var_1x_mapped = var_1x

			var_Annotations_st[key] = var_1x_mapped
		}
		var_Annotations_mapped = var_Annotations_st

		var_Annotations_packed, err := types.ByResourcePropertyType(model.ResourceProperty_MAP).Pack(var_Annotations_mapped)

		if err != nil {
			panic(err)
		}

		properties["annotations"] = var_Annotations_packed
	}
	return properties
}

func (m *EventSelectorMapper) FromProperties(properties map[string]interface{}) *EventSelector {
	var s = m.New()
	if properties["actions"] != nil {

		var_Actions := properties["actions"]
		var_Actions_mapped := []EventAction{}
		for _, v := range var_Actions.([]interface{}) {

			var_4x := v
			var_4x_mapped := (EventAction)(var_4x.(string))

			var_Actions_mapped = append(var_Actions_mapped, var_4x_mapped)
		}

		s.Actions = var_Actions_mapped
	}
	if properties["recordSelector"] != nil {

		var_RecordSelector := properties["recordSelector"]
		var mappedValue = BooleanExpressionMapperInstance.FromProperties(var_RecordSelector.(map[string]interface{}))

		var_RecordSelector_mapped := mappedValue

		s.RecordSelector = var_RecordSelector_mapped
	}
	if properties["namespaces"] != nil {

		var_Namespaces := properties["namespaces"]
		var_Namespaces_mapped := []string{}
		for _, v := range var_Namespaces.([]interface{}) {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_Namespaces_mapped = append(var_Namespaces_mapped, var_4x_mapped)
		}

		s.Namespaces = var_Namespaces_mapped
	}
	if properties["resources"] != nil {

		var_Resources := properties["resources"]
		var_Resources_mapped := []string{}
		for _, v := range var_Resources.([]interface{}) {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_Resources_mapped = append(var_Resources_mapped, var_4x_mapped)
		}

		s.Resources = var_Resources_mapped
	}
	if properties["ids"] != nil {

		var_Ids := properties["ids"]
		var_Ids_mapped := []string{}
		for _, v := range var_Ids.([]interface{}) {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_Ids_mapped = append(var_Ids_mapped, var_4x_mapped)
		}

		s.Ids = var_Ids_mapped
	}
	if properties["annotations"] != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.(map[string]interface{}) {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	return s
}

type RecordSearchParamsMapper struct {
}

func NewRecordSearchParamsMapper() *RecordSearchParamsMapper {
	return &RecordSearchParamsMapper{}
}

var RecordSearchParamsMapperInstance = NewRecordSearchParamsMapper()

func (m *RecordSearchParamsMapper) New() *RecordSearchParams {
	return &RecordSearchParams{}
}

func (m *RecordSearchParamsMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *RecordSearchParamsMapper) ToProperties(recordSearchParams *RecordSearchParams) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Query := recordSearchParams.Query

	if var_Query != nil {
		var var_Query_mapped interface{}

		var_Query_mapped = BooleanExpressionMapperInstance.ToProperties(var_Query)

		var_Query_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Query_mapped)

		if err != nil {
			panic(err)
		}

		properties["query"] = var_Query_packed
	}

	var_Limit := recordSearchParams.Limit

	if var_Limit != nil {
		var var_Limit_mapped interface{}

		var_Limit_mapped = *var_Limit

		var_Limit_packed, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Limit_mapped)

		if err != nil {
			panic(err)
		}

		properties["limit"] = var_Limit_packed
	}

	var_Offset := recordSearchParams.Offset

	if var_Offset != nil {
		var var_Offset_mapped interface{}

		var_Offset_mapped = *var_Offset

		var_Offset_packed, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Offset_mapped)

		if err != nil {
			panic(err)
		}

		properties["offset"] = var_Offset_packed
	}

	var_ResolveReferences := recordSearchParams.ResolveReferences

	if var_ResolveReferences != nil {
		var var_ResolveReferences_mapped interface{}

		var var_ResolveReferences_l []interface{}
		for _, value := range var_ResolveReferences {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = var_5x

			var_ResolveReferences_l = append(var_ResolveReferences_l, var_5x_mapped)
		}
		var_ResolveReferences_mapped = var_ResolveReferences_l

		var_ResolveReferences_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_ResolveReferences_mapped)

		if err != nil {
			panic(err)
		}

		properties["resolveReferences"] = var_ResolveReferences_packed
	}
	return properties
}

func (m *RecordSearchParamsMapper) FromProperties(properties map[string]interface{}) *RecordSearchParams {
	var s = m.New()
	if properties["query"] != nil {

		var_Query := properties["query"]
		var mappedValue = BooleanExpressionMapperInstance.FromProperties(var_Query.(map[string]interface{}))

		var_Query_mapped := mappedValue

		s.Query = var_Query_mapped
	}
	if properties["limit"] != nil {

		var_Limit := properties["limit"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Limit)

		if err != nil {
			panic(err)
		}

		var_Limit_mapped := new(int32)
		*var_Limit_mapped = val.(int32)

		s.Limit = var_Limit_mapped
	}
	if properties["offset"] != nil {

		var_Offset := properties["offset"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Offset)

		if err != nil {
			panic(err)
		}

		var_Offset_mapped := new(int32)
		*var_Offset_mapped = val.(int32)

		s.Offset = var_Offset_mapped
	}
	if properties["resolveReferences"] != nil {

		var_ResolveReferences := properties["resolveReferences"]
		var_ResolveReferences_mapped := []string{}
		for _, v := range var_ResolveReferences.([]interface{}) {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_ResolveReferences_mapped = append(var_ResolveReferences_mapped, var_4x_mapped)
		}

		s.ResolveReferences = var_ResolveReferences_mapped
	}
	return s
}

type EventMapper struct {
}

func NewEventMapper() *EventMapper {
	return &EventMapper{}
}

var EventMapperInstance = NewEventMapper()

func (m *EventMapper) New() *Event {
	return &Event{}
}

func (m *EventMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *EventMapper) ToProperties(event *Event) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Id := event.Id

	var var_Id_mapped interface{}

	var_Id_mapped = var_Id
	var_Id_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Id_mapped)

	if err != nil {
		panic(err)
	}

	properties["id"] = var_Id_packed

	var_Action := event.Action

	var var_Action_mapped interface{}

	var_Action_mapped = string(var_Action)
	var_Action_packed, err := types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(var_Action_mapped)

	if err != nil {
		panic(err)
	}

	properties["action"] = var_Action_packed

	var_RecordSearchParams := event.RecordSearchParams

	if var_RecordSearchParams != nil {
		var var_RecordSearchParams_mapped interface{}

		var_RecordSearchParams_mapped = RecordSearchParamsMapperInstance.ToProperties(var_RecordSearchParams)

		var_RecordSearchParams_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_RecordSearchParams_mapped)

		if err != nil {
			panic(err)
		}

		properties["recordSearchParams"] = var_RecordSearchParams_packed
	}

	var_Resource := event.Resource

	if var_Resource != nil {
		var var_Resource_mapped interface{}

		var_Resource_mapped = ResourceMapperInstance.ToProperties(var_Resource)

		var_Resource_packed, err := types.ByResourcePropertyType(model.ResourceProperty_REFERENCE).Pack(var_Resource_mapped)

		if err != nil {
			panic(err)
		}

		properties["resource"] = var_Resource_packed
	}

	var_Records := event.Records

	if var_Records != nil {
		var var_Records_mapped interface{}

		var var_Records_l []interface{}
		for _, value := range var_Records {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = RecordMapperInstance.ToProperties(var_5x)

			var_Records_l = append(var_Records_l, var_5x_mapped)
		}
		var_Records_mapped = var_Records_l

		var_Records_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_Records_mapped)

		if err != nil {
			panic(err)
		}

		properties["records"] = var_Records_packed
	}

	var_Finalizes := event.Finalizes

	if var_Finalizes != nil {
		var var_Finalizes_mapped interface{}

		var_Finalizes_mapped = *var_Finalizes

		var_Finalizes_packed, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Finalizes_mapped)

		if err != nil {
			panic(err)
		}

		properties["finalizes"] = var_Finalizes_packed
	}

	var_Sync := event.Sync

	if var_Sync != nil {
		var var_Sync_mapped interface{}

		var_Sync_mapped = *var_Sync

		var_Sync_packed, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Sync_mapped)

		if err != nil {
			panic(err)
		}

		properties["sync"] = var_Sync_packed
	}

	var_Time := event.Time

	if var_Time != nil {
		var var_Time_mapped interface{}

		var_Time_mapped = *var_Time

		var_Time_packed, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(var_Time_mapped)

		if err != nil {
			panic(err)
		}

		properties["time"] = var_Time_packed
	}

	var_Total := event.Total

	if var_Total != nil {
		var var_Total_mapped interface{}

		var_Total_mapped = *var_Total

		var_Total_packed, err := types.ByResourcePropertyType(model.ResourceProperty_INT64).Pack(var_Total_mapped)

		if err != nil {
			panic(err)
		}

		properties["total"] = var_Total_packed
	}

	var_Annotations := event.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped interface{}

		var var_Annotations_st = make(map[string]interface{})
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped interface{}

			var_1x_mapped = var_1x

			var_Annotations_st[key] = var_1x_mapped
		}
		var_Annotations_mapped = var_Annotations_st

		var_Annotations_packed, err := types.ByResourcePropertyType(model.ResourceProperty_MAP).Pack(var_Annotations_mapped)

		if err != nil {
			panic(err)
		}

		properties["annotations"] = var_Annotations_packed
	}

	var_Error := event.Error

	if var_Error != nil {
		var var_Error_mapped interface{}

		var_Error_mapped = ErrorMapperInstance.ToProperties(var_Error)

		var_Error_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRUCT).Pack(var_Error_mapped)

		if err != nil {
			panic(err)
		}

		properties["error"] = var_Error_packed
	}
	return properties
}

func (m *EventMapper) FromProperties(properties map[string]interface{}) *Event {
	var s = m.New()
	if properties["id"] != nil {

		var_Id := properties["id"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Id)

		if err != nil {
			panic(err)
		}

		var_Id_mapped := val.(string)

		s.Id = var_Id_mapped
	}
	if properties["action"] != nil {

		var_Action := properties["action"]
		var_Action_mapped := (ExtensionAction)(var_Action.(string))

		s.Action = var_Action_mapped
	}
	if properties["recordSearchParams"] != nil {

		var_RecordSearchParams := properties["recordSearchParams"]
		var mappedValue = RecordSearchParamsMapperInstance.FromProperties(var_RecordSearchParams.(map[string]interface{}))

		var_RecordSearchParams_mapped := mappedValue

		s.RecordSearchParams = var_RecordSearchParams_mapped
	}
	if properties["resource"] != nil {

		var_Resource := properties["resource"]
		var_Resource_mapped := ResourceMapperInstance.FromProperties(var_Resource.(map[string]interface{}))

		s.Resource = var_Resource_mapped
	}
	if properties["records"] != nil {

		var_Records := properties["records"]
		var_Records_mapped := []*Record{}
		for _, v := range var_Records.([]interface{}) {

			var_4x := v
			var_4x_mapped := RecordMapperInstance.FromProperties(var_4x.(map[string]interface{}))

			var_Records_mapped = append(var_Records_mapped, var_4x_mapped)
		}

		s.Records = var_Records_mapped
	}
	if properties["finalizes"] != nil {

		var_Finalizes := properties["finalizes"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Finalizes)

		if err != nil {
			panic(err)
		}

		var_Finalizes_mapped := new(bool)
		*var_Finalizes_mapped = val.(bool)

		s.Finalizes = var_Finalizes_mapped
	}
	if properties["sync"] != nil {

		var_Sync := properties["sync"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Sync)

		if err != nil {
			panic(err)
		}

		var_Sync_mapped := new(bool)
		*var_Sync_mapped = val.(bool)

		s.Sync = var_Sync_mapped
	}
	if properties["time"] != nil {

		var_Time := properties["time"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_Time)

		if err != nil {
			panic(err)
		}

		var_Time_mapped := new(time.Time)
		*var_Time_mapped = val.(time.Time)

		s.Time = var_Time_mapped
	}
	if properties["total"] != nil {

		var_Total := properties["total"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT64).UnPack(var_Total)

		if err != nil {
			panic(err)
		}

		var_Total_mapped := new(int64)
		*var_Total_mapped = val.(int64)

		s.Total = var_Total_mapped
	}
	if properties["annotations"] != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.(map[string]interface{}) {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	if properties["error"] != nil {

		var_Error := properties["error"]
		var mappedValue = ErrorMapperInstance.FromProperties(var_Error.(map[string]interface{}))

		var_Error_mapped := mappedValue

		s.Error = var_Error_mapped
	}
	return s
}

type ErrorFieldMapper struct {
}

func NewErrorFieldMapper() *ErrorFieldMapper {
	return &ErrorFieldMapper{}
}

var ErrorFieldMapperInstance = NewErrorFieldMapper()

func (m *ErrorFieldMapper) New() *ErrorField {
	return &ErrorField{}
}

func (m *ErrorFieldMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ErrorFieldMapper) ToProperties(errorField *ErrorField) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_RecordId := errorField.RecordId

	if var_RecordId != nil {
		var var_RecordId_mapped interface{}

		var_RecordId_mapped = *var_RecordId

		var_RecordId_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_RecordId_mapped)

		if err != nil {
			panic(err)
		}

		properties["recordId"] = var_RecordId_packed
	}

	var_Property := errorField.Property

	if var_Property != nil {
		var var_Property_mapped interface{}

		var_Property_mapped = *var_Property

		var_Property_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Property_mapped)

		if err != nil {
			panic(err)
		}

		properties["property"] = var_Property_packed
	}

	var_Message := errorField.Message

	if var_Message != nil {
		var var_Message_mapped interface{}

		var_Message_mapped = *var_Message

		var_Message_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Message_mapped)

		if err != nil {
			panic(err)
		}

		properties["message"] = var_Message_packed
	}

	var_Value := errorField.Value

	if var_Value != nil {
		var var_Value_mapped interface{}

		var_Value_mapped = var_Value

		var_Value_packed, err := types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_Value_mapped)

		if err != nil {
			panic(err)
		}

		properties["value"] = var_Value_packed
	}
	return properties
}

func (m *ErrorFieldMapper) FromProperties(properties map[string]interface{}) *ErrorField {
	var s = m.New()
	if properties["recordId"] != nil {

		var_RecordId := properties["recordId"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_RecordId)

		if err != nil {
			panic(err)
		}

		var_RecordId_mapped := new(string)
		*var_RecordId_mapped = val.(string)

		s.RecordId = var_RecordId_mapped
	}
	if properties["property"] != nil {

		var_Property := properties["property"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Property)

		if err != nil {
			panic(err)
		}

		var_Property_mapped := new(string)
		*var_Property_mapped = val.(string)

		s.Property = var_Property_mapped
	}
	if properties["message"] != nil {

		var_Message := properties["message"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Message)

		if err != nil {
			panic(err)
		}

		var_Message_mapped := new(string)
		*var_Message_mapped = val.(string)

		s.Message = var_Message_mapped
	}
	if properties["value"] != nil {

		var_Value := properties["value"]
		var_Value_mapped := new(interface{})
		*var_Value_mapped = var_Value

		s.Value = var_Value_mapped
	}
	return s
}

type ErrorMapper struct {
}

func NewErrorMapper() *ErrorMapper {
	return &ErrorMapper{}
}

var ErrorMapperInstance = NewErrorMapper()

func (m *ErrorMapper) New() *Error {
	return &Error{}
}

func (m *ErrorMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Extension",
	}
}

func (m *ErrorMapper) ToProperties(error_ *Error) map[string]interface{} {
	var properties = make(map[string]interface{})

	var_Code := error_.Code

	if var_Code != nil {
		var var_Code_mapped interface{}

		var_Code_mapped = string(*var_Code)

		var_Code_packed, err := types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(var_Code_mapped)

		if err != nil {
			panic(err)
		}

		properties["code"] = var_Code_packed
	}

	var_Message := error_.Message

	if var_Message != nil {
		var var_Message_mapped interface{}

		var_Message_mapped = *var_Message

		var_Message_packed, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Message_mapped)

		if err != nil {
			panic(err)
		}

		properties["message"] = var_Message_packed
	}

	var_Fields := error_.Fields

	if var_Fields != nil {
		var var_Fields_mapped interface{}

		var var_Fields_l []interface{}
		for _, value := range var_Fields {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = ErrorFieldMapperInstance.ToProperties(&var_5x)

			var_Fields_l = append(var_Fields_l, var_5x_mapped)
		}
		var_Fields_mapped = var_Fields_l

		var_Fields_packed, err := types.ByResourcePropertyType(model.ResourceProperty_LIST).Pack(var_Fields_mapped)

		if err != nil {
			panic(err)
		}

		properties["fields"] = var_Fields_packed
	}
	return properties
}

func (m *ErrorMapper) FromProperties(properties map[string]interface{}) *Error {
	var s = m.New()
	if properties["code"] != nil {

		var_Code := properties["code"]
		var_Code_mapped := new(ExtensionCode)
		*var_Code_mapped = (ExtensionCode)(var_Code.(string))

		s.Code = var_Code_mapped
	}
	if properties["message"] != nil {

		var_Message := properties["message"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Message)

		if err != nil {
			panic(err)
		}

		var_Message_mapped := new(string)
		*var_Message_mapped = val.(string)

		s.Message = var_Message_mapped
	}
	if properties["fields"] != nil {

		var_Fields := properties["fields"]
		var_Fields_mapped := []ErrorField{}
		for _, v := range var_Fields.([]interface{}) {

			var_4x := v
			var mappedValue = ErrorFieldMapperInstance.FromProperties(var_4x.(map[string]interface{}))

			var_4x_mapped := *mappedValue

			var_Fields_mapped = append(var_Fields_mapped, var_4x_mapped)
		}

		s.Fields = var_Fields_mapped
	}
	return s
}
