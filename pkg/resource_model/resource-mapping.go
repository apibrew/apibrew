// Code generated by apbr generate. DO NOT EDIT.
// versions:
// 	apbr generate v1.2

//go:build !codeanalysis

package resource_model

import (
	"github.com/apibrew/apibrew/pkg/abs"
	"github.com/apibrew/apibrew/pkg/formats/unstructured"
	"github.com/apibrew/apibrew/pkg/model"
	"github.com/apibrew/apibrew/pkg/types"
	"google.golang.org/protobuf/types/known/structpb"
)

import "github.com/google/uuid"
import "time"

type ResourceMapper struct {
}

func NewResourceMapper() *ResourceMapper {
	return &ResourceMapper{}
}

var ResourceMapperInstance = NewResourceMapper()

func (m *ResourceMapper) New() *Resource {
	return &Resource{}
}

func (m *ResourceMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Resource",
	}
}

func (m *ResourceMapper) ToRecord(resource *Resource) *model.Record {
	var rec = &model.Record{}
	rec.Properties = m.ToProperties(resource)
	return rec
}

func (m *ResourceMapper) FromRecord(record *model.Record) *Resource {
	return m.FromProperties(record.Properties)
}

func (m *ResourceMapper) ToProperties(resource *Resource) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Id := resource.Id

	if var_Id != nil {
		var var_Id_mapped *structpb.Value

		var var_Id_err error
		var_Id_mapped, var_Id_err = types.ByResourcePropertyType(model.ResourceProperty_UUID).Pack(*var_Id)
		if var_Id_err != nil {
			panic(var_Id_err)
		}
		properties["id"] = var_Id_mapped
	}

	var_Version := resource.Version

	var var_Version_mapped *structpb.Value

	var var_Version_err error
	var_Version_mapped, var_Version_err = types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Version)
	if var_Version_err != nil {
		panic(var_Version_err)
	}
	properties["version"] = var_Version_mapped

	var_AuditData := resource.AuditData

	if var_AuditData != nil {
		var var_AuditData_mapped *structpb.Value

		var_AuditData_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ResourceAuditDataMapperInstance.ToProperties(var_AuditData)})
		properties["auditData"] = var_AuditData_mapped
	}

	var_Name := resource.Name

	var var_Name_mapped *structpb.Value

	var var_Name_err error
	var_Name_mapped, var_Name_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Name)
	if var_Name_err != nil {
		panic(var_Name_err)
	}
	properties["name"] = var_Name_mapped

	var_Namespace := resource.Namespace

	if var_Namespace != nil {
		var var_Namespace_mapped *structpb.Value

		var_Namespace_mapped = structpb.NewStructValue(&structpb.Struct{Fields: NamespaceMapperInstance.ToProperties(var_Namespace)})
		properties["namespace"] = var_Namespace_mapped
	}

	var_Virtual := resource.Virtual

	var var_Virtual_mapped *structpb.Value

	var var_Virtual_err error
	var_Virtual_mapped, var_Virtual_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Virtual)
	if var_Virtual_err != nil {
		panic(var_Virtual_err)
	}
	properties["virtual"] = var_Virtual_mapped

	var_Properties := resource.Properties

	var var_Properties_mapped *structpb.Value

	var var_Properties_st *structpb.Struct = new(structpb.Struct)
	var_Properties_st.Fields = make(map[string]*structpb.Value)
	for key, value := range var_Properties {

		var_1x := value
		var var_1x_mapped *structpb.Value

		var_1x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: PropertyMapperInstance.ToProperties(&var_1x)})

		var_Properties_st.Fields[key] = var_1x_mapped
	}
	var_Properties_mapped = structpb.NewStructValue(var_Properties_st)
	properties["properties"] = var_Properties_mapped

	var_Indexes := resource.Indexes

	if var_Indexes != nil {
		var var_Indexes_mapped *structpb.Value

		var var_Indexes_l []*structpb.Value
		for _, value := range var_Indexes {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var_5x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ResourceIndexMapperInstance.ToProperties(&var_5x)})

			var_Indexes_l = append(var_Indexes_l, var_5x_mapped)
		}
		var_Indexes_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Indexes_l})
		properties["indexes"] = var_Indexes_mapped
	}

	var_Types := resource.Types

	if var_Types != nil {
		var var_Types_mapped *structpb.Value

		var var_Types_l []*structpb.Value
		for _, value := range var_Types {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var_5x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: SubTypeMapperInstance.ToProperties(&var_5x)})

			var_Types_l = append(var_Types_l, var_5x_mapped)
		}
		var_Types_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Types_l})
		properties["types"] = var_Types_mapped
	}

	var_Immutable := resource.Immutable

	var var_Immutable_mapped *structpb.Value

	var var_Immutable_err error
	var_Immutable_mapped, var_Immutable_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Immutable)
	if var_Immutable_err != nil {
		panic(var_Immutable_err)
	}
	properties["immutable"] = var_Immutable_mapped

	var_Abstract := resource.Abstract

	var var_Abstract_mapped *structpb.Value

	var var_Abstract_err error
	var_Abstract_mapped, var_Abstract_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Abstract)
	if var_Abstract_err != nil {
		panic(var_Abstract_err)
	}
	properties["abstract"] = var_Abstract_mapped

	var_CheckReferences := resource.CheckReferences

	var var_CheckReferences_mapped *structpb.Value

	var var_CheckReferences_err error
	var_CheckReferences_mapped, var_CheckReferences_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_CheckReferences)
	if var_CheckReferences_err != nil {
		panic(var_CheckReferences_err)
	}
	properties["checkReferences"] = var_CheckReferences_mapped

	var_DataSource := resource.DataSource

	if var_DataSource != nil {
		var var_DataSource_mapped *structpb.Value

		var_DataSource_mapped = structpb.NewStructValue(&structpb.Struct{Fields: DataSourceMapperInstance.ToProperties(var_DataSource)})
		properties["dataSource"] = var_DataSource_mapped
	}

	var_Entity := resource.Entity

	if var_Entity != nil {
		var var_Entity_mapped *structpb.Value

		var var_Entity_err error
		var_Entity_mapped, var_Entity_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Entity)
		if var_Entity_err != nil {
			panic(var_Entity_err)
		}
		properties["entity"] = var_Entity_mapped
	}

	var_Catalog := resource.Catalog

	if var_Catalog != nil {
		var var_Catalog_mapped *structpb.Value

		var var_Catalog_err error
		var_Catalog_mapped, var_Catalog_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Catalog)
		if var_Catalog_err != nil {
			panic(var_Catalog_err)
		}
		properties["catalog"] = var_Catalog_mapped
	}

	var_Title := resource.Title

	if var_Title != nil {
		var var_Title_mapped *structpb.Value

		var var_Title_err error
		var_Title_mapped, var_Title_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Title)
		if var_Title_err != nil {
			panic(var_Title_err)
		}
		properties["title"] = var_Title_mapped
	}

	var_Description := resource.Description

	if var_Description != nil {
		var var_Description_mapped *structpb.Value

		var var_Description_err error
		var_Description_mapped, var_Description_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Description)
		if var_Description_err != nil {
			panic(var_Description_err)
		}
		properties["description"] = var_Description_mapped
	}

	var_Annotations := resource.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped *structpb.Value

		var var_Annotations_st *structpb.Struct = new(structpb.Struct)
		var_Annotations_st.Fields = make(map[string]*structpb.Value)
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped *structpb.Value

			var var_1x_err error
			var_1x_mapped, var_1x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_1x)
			if var_1x_err != nil {
				panic(var_1x_err)
			}

			var_Annotations_st.Fields[key] = var_1x_mapped
		}
		var_Annotations_mapped = structpb.NewStructValue(var_Annotations_st)
		properties["annotations"] = var_Annotations_mapped
	}
	return properties
}

func (m *ResourceMapper) FromProperties(properties map[string]*structpb.Value) *Resource {
	var s = m.New()
	if properties["id"] != nil && properties["id"].AsInterface() != nil {

		var_Id := properties["id"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_UUID).UnPack(var_Id)

		if err != nil {
			panic(err)
		}

		var_Id_mapped := new(uuid.UUID)
		*var_Id_mapped = val.(uuid.UUID)

		s.Id = var_Id_mapped
	}
	if properties["version"] != nil && properties["version"].AsInterface() != nil {

		var_Version := properties["version"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Version)

		if err != nil {
			panic(err)
		}

		var_Version_mapped := val.(int32)

		s.Version = var_Version_mapped
	}
	if properties["auditData"] != nil && properties["auditData"].AsInterface() != nil {

		var_AuditData := properties["auditData"]
		var mappedValue = ResourceAuditDataMapperInstance.FromProperties(var_AuditData.GetStructValue().Fields)

		var_AuditData_mapped := mappedValue

		s.AuditData = var_AuditData_mapped
	}
	if properties["name"] != nil && properties["name"].AsInterface() != nil {

		var_Name := properties["name"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Name)

		if err != nil {
			panic(err)
		}

		var_Name_mapped := val.(string)

		s.Name = var_Name_mapped
	}
	if properties["namespace"] != nil && properties["namespace"].AsInterface() != nil {

		var_Namespace := properties["namespace"]
		var_Namespace_mapped := NamespaceMapperInstance.FromProperties(var_Namespace.GetStructValue().Fields)

		s.Namespace = var_Namespace_mapped
	}
	if properties["virtual"] != nil && properties["virtual"].AsInterface() != nil {

		var_Virtual := properties["virtual"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Virtual)

		if err != nil {
			panic(err)
		}

		var_Virtual_mapped := val.(bool)

		s.Virtual = var_Virtual_mapped
	}
	if properties["properties"] != nil && properties["properties"].AsInterface() != nil {

		var_Properties := properties["properties"]
		var_Properties_mapped := make(map[string]Property)
		for k, v := range var_Properties.GetStructValue().Fields {

			var_3x := v
			var mappedValue = PropertyMapperInstance.FromProperties(var_3x.GetStructValue().Fields)

			var_3x_mapped := *mappedValue

			var_Properties_mapped[k] = var_3x_mapped
		}

		s.Properties = var_Properties_mapped
	}
	if properties["indexes"] != nil && properties["indexes"].AsInterface() != nil {

		var_Indexes := properties["indexes"]
		var_Indexes_mapped := []ResourceIndex{}
		for _, v := range var_Indexes.GetListValue().Values {

			var_4x := v
			var mappedValue = ResourceIndexMapperInstance.FromProperties(var_4x.GetStructValue().Fields)

			var_4x_mapped := *mappedValue

			var_Indexes_mapped = append(var_Indexes_mapped, var_4x_mapped)
		}

		s.Indexes = var_Indexes_mapped
	}
	if properties["types"] != nil && properties["types"].AsInterface() != nil {

		var_Types := properties["types"]
		var_Types_mapped := []SubType{}
		for _, v := range var_Types.GetListValue().Values {

			var_4x := v
			var mappedValue = SubTypeMapperInstance.FromProperties(var_4x.GetStructValue().Fields)

			var_4x_mapped := *mappedValue

			var_Types_mapped = append(var_Types_mapped, var_4x_mapped)
		}

		s.Types = var_Types_mapped
	}
	if properties["immutable"] != nil && properties["immutable"].AsInterface() != nil {

		var_Immutable := properties["immutable"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Immutable)

		if err != nil {
			panic(err)
		}

		var_Immutable_mapped := val.(bool)

		s.Immutable = var_Immutable_mapped
	}
	if properties["abstract"] != nil && properties["abstract"].AsInterface() != nil {

		var_Abstract := properties["abstract"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Abstract)

		if err != nil {
			panic(err)
		}

		var_Abstract_mapped := val.(bool)

		s.Abstract = var_Abstract_mapped
	}
	if properties["checkReferences"] != nil && properties["checkReferences"].AsInterface() != nil {

		var_CheckReferences := properties["checkReferences"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_CheckReferences)

		if err != nil {
			panic(err)
		}

		var_CheckReferences_mapped := val.(bool)

		s.CheckReferences = var_CheckReferences_mapped
	}
	if properties["dataSource"] != nil && properties["dataSource"].AsInterface() != nil {

		var_DataSource := properties["dataSource"]
		var_DataSource_mapped := DataSourceMapperInstance.FromProperties(var_DataSource.GetStructValue().Fields)

		s.DataSource = var_DataSource_mapped
	}
	if properties["entity"] != nil && properties["entity"].AsInterface() != nil {

		var_Entity := properties["entity"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Entity)

		if err != nil {
			panic(err)
		}

		var_Entity_mapped := new(string)
		*var_Entity_mapped = val.(string)

		s.Entity = var_Entity_mapped
	}
	if properties["catalog"] != nil && properties["catalog"].AsInterface() != nil {

		var_Catalog := properties["catalog"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Catalog)

		if err != nil {
			panic(err)
		}

		var_Catalog_mapped := new(string)
		*var_Catalog_mapped = val.(string)

		s.Catalog = var_Catalog_mapped
	}
	if properties["title"] != nil && properties["title"].AsInterface() != nil {

		var_Title := properties["title"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Title)

		if err != nil {
			panic(err)
		}

		var_Title_mapped := new(string)
		*var_Title_mapped = val.(string)

		s.Title = var_Title_mapped
	}
	if properties["description"] != nil && properties["description"].AsInterface() != nil {

		var_Description := properties["description"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Description)

		if err != nil {
			panic(err)
		}

		var_Description_mapped := new(string)
		*var_Description_mapped = val.(string)

		s.Description = var_Description_mapped
	}
	if properties["annotations"] != nil && properties["annotations"].AsInterface() != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.GetStructValue().Fields {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	return s
}

func (m *ResourceMapper) ToUnstructured(resource *Resource) unstructured.Unstructured {
	var properties unstructured.Unstructured = make(unstructured.Unstructured)
	properties["type"] = "system/Resource"

	var_Id := resource.Id

	if var_Id != nil {
		var var_Id_mapped interface{}

		var_Id_mapped = var_Id.String()
		properties["id"] = var_Id_mapped
	}

	var_Version := resource.Version

	var var_Version_mapped interface{}

	var_Version_mapped = var_Version
	properties["version"] = var_Version_mapped

	var_AuditData := resource.AuditData

	if var_AuditData != nil {
		var var_AuditData_mapped interface{}

		var_AuditData_mapped = ResourceAuditDataMapperInstance.ToUnstructured(var_AuditData)
		properties["auditData"] = var_AuditData_mapped
	}

	var_Name := resource.Name

	var var_Name_mapped interface{}

	var_Name_mapped = var_Name
	properties["name"] = var_Name_mapped

	var_Namespace := resource.Namespace

	if var_Namespace != nil {
		var var_Namespace_mapped interface{}

		var_Namespace_mapped = NamespaceMapperInstance.ToUnstructured(var_Namespace)
		properties["namespace"] = var_Namespace_mapped
	}

	var_Virtual := resource.Virtual

	var var_Virtual_mapped interface{}

	var_Virtual_mapped = var_Virtual
	properties["virtual"] = var_Virtual_mapped

	var_Properties := resource.Properties

	var var_Properties_mapped interface{}

	var var_Properties_st map[string]interface{} = make(map[string]interface{})
	for key, value := range var_Properties {

		var_1x := value
		var var_1x_mapped interface{}

		var_1x_mapped = PropertyMapperInstance.ToUnstructured(&var_1x)

		var_Properties_st[key] = var_1x_mapped
	}
	var_Properties_mapped = var_Properties_st
	properties["properties"] = var_Properties_mapped

	var_Indexes := resource.Indexes

	if var_Indexes != nil {
		var var_Indexes_mapped interface{}

		var var_Indexes_l []interface{}
		for _, value := range var_Indexes {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = ResourceIndexMapperInstance.ToUnstructured(&var_5x)

			var_Indexes_l = append(var_Indexes_l, var_5x_mapped)
		}
		var_Indexes_mapped = var_Indexes_l
		properties["indexes"] = var_Indexes_mapped
	}

	var_Types := resource.Types

	if var_Types != nil {
		var var_Types_mapped interface{}

		var var_Types_l []interface{}
		for _, value := range var_Types {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = SubTypeMapperInstance.ToUnstructured(&var_5x)

			var_Types_l = append(var_Types_l, var_5x_mapped)
		}
		var_Types_mapped = var_Types_l
		properties["types"] = var_Types_mapped
	}

	var_Immutable := resource.Immutable

	var var_Immutable_mapped interface{}

	var_Immutable_mapped = var_Immutable
	properties["immutable"] = var_Immutable_mapped

	var_Abstract := resource.Abstract

	var var_Abstract_mapped interface{}

	var_Abstract_mapped = var_Abstract
	properties["abstract"] = var_Abstract_mapped

	var_CheckReferences := resource.CheckReferences

	var var_CheckReferences_mapped interface{}

	var_CheckReferences_mapped = var_CheckReferences
	properties["checkReferences"] = var_CheckReferences_mapped

	var_DataSource := resource.DataSource

	if var_DataSource != nil {
		var var_DataSource_mapped interface{}

		var_DataSource_mapped = DataSourceMapperInstance.ToUnstructured(var_DataSource)
		properties["dataSource"] = var_DataSource_mapped
	}

	var_Entity := resource.Entity

	if var_Entity != nil {
		var var_Entity_mapped interface{}

		var_Entity_mapped = *var_Entity
		properties["entity"] = var_Entity_mapped
	}

	var_Catalog := resource.Catalog

	if var_Catalog != nil {
		var var_Catalog_mapped interface{}

		var_Catalog_mapped = *var_Catalog
		properties["catalog"] = var_Catalog_mapped
	}

	var_Title := resource.Title

	if var_Title != nil {
		var var_Title_mapped interface{}

		var_Title_mapped = *var_Title
		properties["title"] = var_Title_mapped
	}

	var_Description := resource.Description

	if var_Description != nil {
		var var_Description_mapped interface{}

		var_Description_mapped = *var_Description
		properties["description"] = var_Description_mapped
	}

	var_Annotations := resource.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped interface{}

		var var_Annotations_st map[string]interface{} = make(map[string]interface{})
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped interface{}

			var_1x_mapped = var_1x

			var_Annotations_st[key] = var_1x_mapped
		}
		var_Annotations_mapped = var_Annotations_st
		properties["annotations"] = var_Annotations_mapped
	}

	return properties
}

type PropertyMapper struct {
}

func NewPropertyMapper() *PropertyMapper {
	return &PropertyMapper{}
}

var PropertyMapperInstance = NewPropertyMapper()

func (m *PropertyMapper) New() *Property {
	return &Property{}
}

func (m *PropertyMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Resource",
	}
}

func (m *PropertyMapper) ToProperties(property *Property) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Type := property.Type

	var var_Type_mapped *structpb.Value

	var var_Type_err error
	var_Type_mapped, var_Type_err = types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(string(var_Type))
	if var_Type_err != nil {
		panic(var_Type_err)
	}
	properties["type"] = var_Type_mapped

	var_TypeRef := property.TypeRef

	if var_TypeRef != nil {
		var var_TypeRef_mapped *structpb.Value

		var var_TypeRef_err error
		var_TypeRef_mapped, var_TypeRef_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_TypeRef)
		if var_TypeRef_err != nil {
			panic(var_TypeRef_err)
		}
		properties["typeRef"] = var_TypeRef_mapped
	}

	var_Primary := property.Primary

	var var_Primary_mapped *structpb.Value

	var var_Primary_err error
	var_Primary_mapped, var_Primary_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Primary)
	if var_Primary_err != nil {
		panic(var_Primary_err)
	}
	properties["primary"] = var_Primary_mapped

	var_Required := property.Required

	var var_Required_mapped *structpb.Value

	var var_Required_err error
	var_Required_mapped, var_Required_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Required)
	if var_Required_err != nil {
		panic(var_Required_err)
	}
	properties["required"] = var_Required_mapped

	var_Unique := property.Unique

	var var_Unique_mapped *structpb.Value

	var var_Unique_err error
	var_Unique_mapped, var_Unique_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Unique)
	if var_Unique_err != nil {
		panic(var_Unique_err)
	}
	properties["unique"] = var_Unique_mapped

	var_Immutable := property.Immutable

	var var_Immutable_mapped *structpb.Value

	var var_Immutable_err error
	var_Immutable_mapped, var_Immutable_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Immutable)
	if var_Immutable_err != nil {
		panic(var_Immutable_err)
	}
	properties["immutable"] = var_Immutable_mapped

	var_Virtual := property.Virtual

	var var_Virtual_mapped *structpb.Value

	var var_Virtual_err error
	var_Virtual_mapped, var_Virtual_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(var_Virtual)
	if var_Virtual_err != nil {
		panic(var_Virtual_err)
	}
	properties["virtual"] = var_Virtual_mapped

	var_Length := property.Length

	var var_Length_mapped *structpb.Value

	var var_Length_err error
	var_Length_mapped, var_Length_err = types.ByResourcePropertyType(model.ResourceProperty_INT32).Pack(var_Length)
	if var_Length_err != nil {
		panic(var_Length_err)
	}
	properties["length"] = var_Length_mapped

	var_Item := property.Item

	if var_Item != nil {
		var var_Item_mapped *structpb.Value

		var_Item_mapped = structpb.NewStructValue(&structpb.Struct{Fields: PropertyMapperInstance.ToProperties(var_Item)})
		properties["item"] = var_Item_mapped
	}

	var_Reference := property.Reference

	if var_Reference != nil {
		var var_Reference_mapped *structpb.Value

		var var_Reference_err error
		var_Reference_mapped, var_Reference_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Reference)
		if var_Reference_err != nil {
			panic(var_Reference_err)
		}
		properties["reference"] = var_Reference_mapped
	}

	var_BackReference := property.BackReference

	if var_BackReference != nil {
		var var_BackReference_mapped *structpb.Value

		var var_BackReference_err error
		var_BackReference_mapped, var_BackReference_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_BackReference)
		if var_BackReference_err != nil {
			panic(var_BackReference_err)
		}
		properties["backReference"] = var_BackReference_mapped
	}

	var_DefaultValue := property.DefaultValue

	if var_DefaultValue != nil {
		var var_DefaultValue_mapped *structpb.Value

		var var_DefaultValue_err error
		var_DefaultValue_mapped, var_DefaultValue_err = types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_DefaultValue)
		if var_DefaultValue_err != nil {
			panic(var_DefaultValue_err)
		}
		properties["defaultValue"] = var_DefaultValue_mapped
	}

	var_EnumValues := property.EnumValues

	if var_EnumValues != nil {
		var var_EnumValues_mapped *structpb.Value

		var var_EnumValues_l []*structpb.Value
		for _, value := range var_EnumValues {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var var_5x_err error
			var_5x_mapped, var_5x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_5x)
			if var_5x_err != nil {
				panic(var_5x_err)
			}

			var_EnumValues_l = append(var_EnumValues_l, var_5x_mapped)
		}
		var_EnumValues_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_EnumValues_l})
		properties["enumValues"] = var_EnumValues_mapped
	}

	var_ExampleValue := property.ExampleValue

	if var_ExampleValue != nil {
		var var_ExampleValue_mapped *structpb.Value

		var var_ExampleValue_err error
		var_ExampleValue_mapped, var_ExampleValue_err = types.ByResourcePropertyType(model.ResourceProperty_OBJECT).Pack(var_ExampleValue)
		if var_ExampleValue_err != nil {
			panic(var_ExampleValue_err)
		}
		properties["exampleValue"] = var_ExampleValue_mapped
	}

	var_Title := property.Title

	if var_Title != nil {
		var var_Title_mapped *structpb.Value

		var var_Title_err error
		var_Title_mapped, var_Title_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Title)
		if var_Title_err != nil {
			panic(var_Title_err)
		}
		properties["title"] = var_Title_mapped
	}

	var_Description := property.Description

	if var_Description != nil {
		var var_Description_mapped *structpb.Value

		var var_Description_err error
		var_Description_mapped, var_Description_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Description)
		if var_Description_err != nil {
			panic(var_Description_err)
		}
		properties["description"] = var_Description_mapped
	}

	var_Annotations := property.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped *structpb.Value

		var var_Annotations_st *structpb.Struct = new(structpb.Struct)
		var_Annotations_st.Fields = make(map[string]*structpb.Value)
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped *structpb.Value

			var var_1x_err error
			var_1x_mapped, var_1x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_1x)
			if var_1x_err != nil {
				panic(var_1x_err)
			}

			var_Annotations_st.Fields[key] = var_1x_mapped
		}
		var_Annotations_mapped = structpb.NewStructValue(var_Annotations_st)
		properties["annotations"] = var_Annotations_mapped
	}
	return properties
}

func (m *PropertyMapper) FromProperties(properties map[string]*structpb.Value) *Property {
	var s = m.New()
	if properties["type"] != nil && properties["type"].AsInterface() != nil {

		var_Type := properties["type"]
		var_Type_mapped := (ResourceType)(var_Type.GetStringValue())

		s.Type = var_Type_mapped
	}
	if properties["typeRef"] != nil && properties["typeRef"].AsInterface() != nil {

		var_TypeRef := properties["typeRef"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_TypeRef)

		if err != nil {
			panic(err)
		}

		var_TypeRef_mapped := new(string)
		*var_TypeRef_mapped = val.(string)

		s.TypeRef = var_TypeRef_mapped
	}
	if properties["primary"] != nil && properties["primary"].AsInterface() != nil {

		var_Primary := properties["primary"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Primary)

		if err != nil {
			panic(err)
		}

		var_Primary_mapped := val.(bool)

		s.Primary = var_Primary_mapped
	}
	if properties["required"] != nil && properties["required"].AsInterface() != nil {

		var_Required := properties["required"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Required)

		if err != nil {
			panic(err)
		}

		var_Required_mapped := val.(bool)

		s.Required = var_Required_mapped
	}
	if properties["unique"] != nil && properties["unique"].AsInterface() != nil {

		var_Unique := properties["unique"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Unique)

		if err != nil {
			panic(err)
		}

		var_Unique_mapped := val.(bool)

		s.Unique = var_Unique_mapped
	}
	if properties["immutable"] != nil && properties["immutable"].AsInterface() != nil {

		var_Immutable := properties["immutable"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Immutable)

		if err != nil {
			panic(err)
		}

		var_Immutable_mapped := val.(bool)

		s.Immutable = var_Immutable_mapped
	}
	if properties["virtual"] != nil && properties["virtual"].AsInterface() != nil {

		var_Virtual := properties["virtual"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Virtual)

		if err != nil {
			panic(err)
		}

		var_Virtual_mapped := val.(bool)

		s.Virtual = var_Virtual_mapped
	}
	if properties["length"] != nil && properties["length"].AsInterface() != nil {

		var_Length := properties["length"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_INT32).UnPack(var_Length)

		if err != nil {
			panic(err)
		}

		var_Length_mapped := val.(int32)

		s.Length = var_Length_mapped
	}
	if properties["item"] != nil && properties["item"].AsInterface() != nil {

		var_Item := properties["item"]
		var mappedValue = PropertyMapperInstance.FromProperties(var_Item.GetStructValue().Fields)

		var_Item_mapped := mappedValue

		s.Item = var_Item_mapped
	}
	if properties["reference"] != nil && properties["reference"].AsInterface() != nil {

		var_Reference := properties["reference"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Reference)

		if err != nil {
			panic(err)
		}

		var_Reference_mapped := new(string)
		*var_Reference_mapped = val.(string)

		s.Reference = var_Reference_mapped
	}
	if properties["backReference"] != nil && properties["backReference"].AsInterface() != nil {

		var_BackReference := properties["backReference"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_BackReference)

		if err != nil {
			panic(err)
		}

		var_BackReference_mapped := new(string)
		*var_BackReference_mapped = val.(string)

		s.BackReference = var_BackReference_mapped
	}
	if properties["defaultValue"] != nil && properties["defaultValue"].AsInterface() != nil {

		var_DefaultValue := properties["defaultValue"]
		var_DefaultValue_mapped := new(interface{})
		*var_DefaultValue_mapped = unstructured.FromValue(var_DefaultValue)

		s.DefaultValue = var_DefaultValue_mapped
	}
	if properties["enumValues"] != nil && properties["enumValues"].AsInterface() != nil {

		var_EnumValues := properties["enumValues"]
		var_EnumValues_mapped := []string{}
		for _, v := range var_EnumValues.GetListValue().Values {

			var_4x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_4x)

			if err != nil {
				panic(err)
			}

			var_4x_mapped := val.(string)

			var_EnumValues_mapped = append(var_EnumValues_mapped, var_4x_mapped)
		}

		s.EnumValues = var_EnumValues_mapped
	}
	if properties["exampleValue"] != nil && properties["exampleValue"].AsInterface() != nil {

		var_ExampleValue := properties["exampleValue"]
		var_ExampleValue_mapped := new(interface{})
		*var_ExampleValue_mapped = unstructured.FromValue(var_ExampleValue)

		s.ExampleValue = var_ExampleValue_mapped
	}
	if properties["title"] != nil && properties["title"].AsInterface() != nil {

		var_Title := properties["title"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Title)

		if err != nil {
			panic(err)
		}

		var_Title_mapped := new(string)
		*var_Title_mapped = val.(string)

		s.Title = var_Title_mapped
	}
	if properties["description"] != nil && properties["description"].AsInterface() != nil {

		var_Description := properties["description"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Description)

		if err != nil {
			panic(err)
		}

		var_Description_mapped := new(string)
		*var_Description_mapped = val.(string)

		s.Description = var_Description_mapped
	}
	if properties["annotations"] != nil && properties["annotations"].AsInterface() != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.GetStructValue().Fields {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	return s
}

func (m *PropertyMapper) ToUnstructured(property *Property) unstructured.Unstructured {
	var properties unstructured.Unstructured = make(unstructured.Unstructured)

	var_Type := property.Type

	var var_Type_mapped interface{}

	var_Type_mapped = string(var_Type)
	properties["type"] = var_Type_mapped

	var_TypeRef := property.TypeRef

	if var_TypeRef != nil {
		var var_TypeRef_mapped interface{}

		var_TypeRef_mapped = *var_TypeRef
		properties["typeRef"] = var_TypeRef_mapped
	}

	var_Primary := property.Primary

	var var_Primary_mapped interface{}

	var_Primary_mapped = var_Primary
	properties["primary"] = var_Primary_mapped

	var_Required := property.Required

	var var_Required_mapped interface{}

	var_Required_mapped = var_Required
	properties["required"] = var_Required_mapped

	var_Unique := property.Unique

	var var_Unique_mapped interface{}

	var_Unique_mapped = var_Unique
	properties["unique"] = var_Unique_mapped

	var_Immutable := property.Immutable

	var var_Immutable_mapped interface{}

	var_Immutable_mapped = var_Immutable
	properties["immutable"] = var_Immutable_mapped

	var_Virtual := property.Virtual

	var var_Virtual_mapped interface{}

	var_Virtual_mapped = var_Virtual
	properties["virtual"] = var_Virtual_mapped

	var_Length := property.Length

	var var_Length_mapped interface{}

	var_Length_mapped = var_Length
	properties["length"] = var_Length_mapped

	var_Item := property.Item

	if var_Item != nil {
		var var_Item_mapped interface{}

		var_Item_mapped = PropertyMapperInstance.ToUnstructured(var_Item)
		properties["item"] = var_Item_mapped
	}

	var_Reference := property.Reference

	if var_Reference != nil {
		var var_Reference_mapped interface{}

		var_Reference_mapped = *var_Reference
		properties["reference"] = var_Reference_mapped
	}

	var_BackReference := property.BackReference

	if var_BackReference != nil {
		var var_BackReference_mapped interface{}

		var_BackReference_mapped = *var_BackReference
		properties["backReference"] = var_BackReference_mapped
	}

	var_DefaultValue := property.DefaultValue

	if var_DefaultValue != nil {
		var var_DefaultValue_mapped interface{}

		var_DefaultValue_mapped = var_DefaultValue
		properties["defaultValue"] = var_DefaultValue_mapped
	}

	var_EnumValues := property.EnumValues

	if var_EnumValues != nil {
		var var_EnumValues_mapped interface{}

		var var_EnumValues_l []interface{}
		for _, value := range var_EnumValues {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = var_5x

			var_EnumValues_l = append(var_EnumValues_l, var_5x_mapped)
		}
		var_EnumValues_mapped = var_EnumValues_l
		properties["enumValues"] = var_EnumValues_mapped
	}

	var_ExampleValue := property.ExampleValue

	if var_ExampleValue != nil {
		var var_ExampleValue_mapped interface{}

		var_ExampleValue_mapped = var_ExampleValue
		properties["exampleValue"] = var_ExampleValue_mapped
	}

	var_Title := property.Title

	if var_Title != nil {
		var var_Title_mapped interface{}

		var_Title_mapped = *var_Title
		properties["title"] = var_Title_mapped
	}

	var_Description := property.Description

	if var_Description != nil {
		var var_Description_mapped interface{}

		var_Description_mapped = *var_Description
		properties["description"] = var_Description_mapped
	}

	var_Annotations := property.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped interface{}

		var var_Annotations_st map[string]interface{} = make(map[string]interface{})
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped interface{}

			var_1x_mapped = var_1x

			var_Annotations_st[key] = var_1x_mapped
		}
		var_Annotations_mapped = var_Annotations_st
		properties["annotations"] = var_Annotations_mapped
	}

	return properties
}

type SubTypeMapper struct {
}

func NewSubTypeMapper() *SubTypeMapper {
	return &SubTypeMapper{}
}

var SubTypeMapperInstance = NewSubTypeMapper()

func (m *SubTypeMapper) New() *SubType {
	return &SubType{}
}

func (m *SubTypeMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Resource",
	}
}

func (m *SubTypeMapper) ToProperties(subType *SubType) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Name := subType.Name

	var var_Name_mapped *structpb.Value

	var var_Name_err error
	var_Name_mapped, var_Name_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Name)
	if var_Name_err != nil {
		panic(var_Name_err)
	}
	properties["name"] = var_Name_mapped

	var_Title := subType.Title

	if var_Title != nil {
		var var_Title_mapped *structpb.Value

		var var_Title_err error
		var_Title_mapped, var_Title_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Title)
		if var_Title_err != nil {
			panic(var_Title_err)
		}
		properties["title"] = var_Title_mapped
	}

	var_Description := subType.Description

	if var_Description != nil {
		var var_Description_mapped *structpb.Value

		var var_Description_err error
		var_Description_mapped, var_Description_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_Description)
		if var_Description_err != nil {
			panic(var_Description_err)
		}
		properties["description"] = var_Description_mapped
	}

	var_Properties := subType.Properties

	var var_Properties_mapped *structpb.Value

	var var_Properties_st *structpb.Struct = new(structpb.Struct)
	var_Properties_st.Fields = make(map[string]*structpb.Value)
	for key, value := range var_Properties {

		var_1x := value
		var var_1x_mapped *structpb.Value

		var_1x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: PropertyMapperInstance.ToProperties(&var_1x)})

		var_Properties_st.Fields[key] = var_1x_mapped
	}
	var_Properties_mapped = structpb.NewStructValue(var_Properties_st)
	properties["properties"] = var_Properties_mapped
	return properties
}

func (m *SubTypeMapper) FromProperties(properties map[string]*structpb.Value) *SubType {
	var s = m.New()
	if properties["name"] != nil && properties["name"].AsInterface() != nil {

		var_Name := properties["name"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Name)

		if err != nil {
			panic(err)
		}

		var_Name_mapped := val.(string)

		s.Name = var_Name_mapped
	}
	if properties["title"] != nil && properties["title"].AsInterface() != nil {

		var_Title := properties["title"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Title)

		if err != nil {
			panic(err)
		}

		var_Title_mapped := new(string)
		*var_Title_mapped = val.(string)

		s.Title = var_Title_mapped
	}
	if properties["description"] != nil && properties["description"].AsInterface() != nil {

		var_Description := properties["description"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Description)

		if err != nil {
			panic(err)
		}

		var_Description_mapped := new(string)
		*var_Description_mapped = val.(string)

		s.Description = var_Description_mapped
	}
	if properties["properties"] != nil && properties["properties"].AsInterface() != nil {

		var_Properties := properties["properties"]
		var_Properties_mapped := make(map[string]Property)
		for k, v := range var_Properties.GetStructValue().Fields {

			var_3x := v
			var mappedValue = PropertyMapperInstance.FromProperties(var_3x.GetStructValue().Fields)

			var_3x_mapped := *mappedValue

			var_Properties_mapped[k] = var_3x_mapped
		}

		s.Properties = var_Properties_mapped
	}
	return s
}

func (m *SubTypeMapper) ToUnstructured(subType *SubType) unstructured.Unstructured {
	var properties unstructured.Unstructured = make(unstructured.Unstructured)

	var_Name := subType.Name

	var var_Name_mapped interface{}

	var_Name_mapped = var_Name
	properties["name"] = var_Name_mapped

	var_Title := subType.Title

	if var_Title != nil {
		var var_Title_mapped interface{}

		var_Title_mapped = *var_Title
		properties["title"] = var_Title_mapped
	}

	var_Description := subType.Description

	if var_Description != nil {
		var var_Description_mapped interface{}

		var_Description_mapped = *var_Description
		properties["description"] = var_Description_mapped
	}

	var_Properties := subType.Properties

	var var_Properties_mapped interface{}

	var var_Properties_st map[string]interface{} = make(map[string]interface{})
	for key, value := range var_Properties {

		var_1x := value
		var var_1x_mapped interface{}

		var_1x_mapped = PropertyMapperInstance.ToUnstructured(&var_1x)

		var_Properties_st[key] = var_1x_mapped
	}
	var_Properties_mapped = var_Properties_st
	properties["properties"] = var_Properties_mapped

	return properties
}

type ResourceAuditDataMapper struct {
}

func NewResourceAuditDataMapper() *ResourceAuditDataMapper {
	return &ResourceAuditDataMapper{}
}

var ResourceAuditDataMapperInstance = NewResourceAuditDataMapper()

func (m *ResourceAuditDataMapper) New() *ResourceAuditData {
	return &ResourceAuditData{}
}

func (m *ResourceAuditDataMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Resource",
	}
}

func (m *ResourceAuditDataMapper) ToProperties(resourceAuditData *ResourceAuditData) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_CreatedBy := resourceAuditData.CreatedBy

	if var_CreatedBy != nil {
		var var_CreatedBy_mapped *structpb.Value

		var var_CreatedBy_err error
		var_CreatedBy_mapped, var_CreatedBy_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_CreatedBy)
		if var_CreatedBy_err != nil {
			panic(var_CreatedBy_err)
		}
		properties["createdBy"] = var_CreatedBy_mapped
	}

	var_UpdatedBy := resourceAuditData.UpdatedBy

	if var_UpdatedBy != nil {
		var var_UpdatedBy_mapped *structpb.Value

		var var_UpdatedBy_err error
		var_UpdatedBy_mapped, var_UpdatedBy_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(*var_UpdatedBy)
		if var_UpdatedBy_err != nil {
			panic(var_UpdatedBy_err)
		}
		properties["updatedBy"] = var_UpdatedBy_mapped
	}

	var_CreatedOn := resourceAuditData.CreatedOn

	if var_CreatedOn != nil {
		var var_CreatedOn_mapped *structpb.Value

		var var_CreatedOn_err error
		var_CreatedOn_mapped, var_CreatedOn_err = types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(*var_CreatedOn)
		if var_CreatedOn_err != nil {
			panic(var_CreatedOn_err)
		}
		properties["createdOn"] = var_CreatedOn_mapped
	}

	var_UpdatedOn := resourceAuditData.UpdatedOn

	if var_UpdatedOn != nil {
		var var_UpdatedOn_mapped *structpb.Value

		var var_UpdatedOn_err error
		var_UpdatedOn_mapped, var_UpdatedOn_err = types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).Pack(*var_UpdatedOn)
		if var_UpdatedOn_err != nil {
			panic(var_UpdatedOn_err)
		}
		properties["updatedOn"] = var_UpdatedOn_mapped
	}
	return properties
}

func (m *ResourceAuditDataMapper) FromProperties(properties map[string]*structpb.Value) *ResourceAuditData {
	var s = m.New()
	if properties["createdBy"] != nil && properties["createdBy"].AsInterface() != nil {

		var_CreatedBy := properties["createdBy"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_CreatedBy)

		if err != nil {
			panic(err)
		}

		var_CreatedBy_mapped := new(string)
		*var_CreatedBy_mapped = val.(string)

		s.CreatedBy = var_CreatedBy_mapped
	}
	if properties["updatedBy"] != nil && properties["updatedBy"].AsInterface() != nil {

		var_UpdatedBy := properties["updatedBy"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_UpdatedBy)

		if err != nil {
			panic(err)
		}

		var_UpdatedBy_mapped := new(string)
		*var_UpdatedBy_mapped = val.(string)

		s.UpdatedBy = var_UpdatedBy_mapped
	}
	if properties["createdOn"] != nil && properties["createdOn"].AsInterface() != nil {

		var_CreatedOn := properties["createdOn"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_CreatedOn)

		if err != nil {
			panic(err)
		}

		var_CreatedOn_mapped := new(time.Time)
		*var_CreatedOn_mapped = val.(time.Time)

		s.CreatedOn = var_CreatedOn_mapped
	}
	if properties["updatedOn"] != nil && properties["updatedOn"].AsInterface() != nil {

		var_UpdatedOn := properties["updatedOn"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_TIMESTAMP).UnPack(var_UpdatedOn)

		if err != nil {
			panic(err)
		}

		var_UpdatedOn_mapped := new(time.Time)
		*var_UpdatedOn_mapped = val.(time.Time)

		s.UpdatedOn = var_UpdatedOn_mapped
	}
	return s
}

func (m *ResourceAuditDataMapper) ToUnstructured(resourceAuditData *ResourceAuditData) unstructured.Unstructured {
	var properties unstructured.Unstructured = make(unstructured.Unstructured)

	var_CreatedBy := resourceAuditData.CreatedBy

	if var_CreatedBy != nil {
		var var_CreatedBy_mapped interface{}

		var_CreatedBy_mapped = *var_CreatedBy
		properties["createdBy"] = var_CreatedBy_mapped
	}

	var_UpdatedBy := resourceAuditData.UpdatedBy

	if var_UpdatedBy != nil {
		var var_UpdatedBy_mapped interface{}

		var_UpdatedBy_mapped = *var_UpdatedBy
		properties["updatedBy"] = var_UpdatedBy_mapped
	}

	var_CreatedOn := resourceAuditData.CreatedOn

	if var_CreatedOn != nil {
		var var_CreatedOn_mapped interface{}

		var_CreatedOn_mapped = *var_CreatedOn
		properties["createdOn"] = var_CreatedOn_mapped
	}

	var_UpdatedOn := resourceAuditData.UpdatedOn

	if var_UpdatedOn != nil {
		var var_UpdatedOn_mapped interface{}

		var_UpdatedOn_mapped = *var_UpdatedOn
		properties["updatedOn"] = var_UpdatedOn_mapped
	}

	return properties
}

type ResourceIndexPropertyMapper struct {
}

func NewResourceIndexPropertyMapper() *ResourceIndexPropertyMapper {
	return &ResourceIndexPropertyMapper{}
}

var ResourceIndexPropertyMapperInstance = NewResourceIndexPropertyMapper()

func (m *ResourceIndexPropertyMapper) New() *ResourceIndexProperty {
	return &ResourceIndexProperty{}
}

func (m *ResourceIndexPropertyMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Resource",
	}
}

func (m *ResourceIndexPropertyMapper) ToProperties(resourceIndexProperty *ResourceIndexProperty) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Name := resourceIndexProperty.Name

	var var_Name_mapped *structpb.Value

	var var_Name_err error
	var_Name_mapped, var_Name_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_Name)
	if var_Name_err != nil {
		panic(var_Name_err)
	}
	properties["name"] = var_Name_mapped

	var_Order := resourceIndexProperty.Order

	if var_Order != nil {
		var var_Order_mapped *structpb.Value

		var var_Order_err error
		var_Order_mapped, var_Order_err = types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(string(*var_Order))
		if var_Order_err != nil {
			panic(var_Order_err)
		}
		properties["order"] = var_Order_mapped
	}
	return properties
}

func (m *ResourceIndexPropertyMapper) FromProperties(properties map[string]*structpb.Value) *ResourceIndexProperty {
	var s = m.New()
	if properties["name"] != nil && properties["name"].AsInterface() != nil {

		var_Name := properties["name"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_Name)

		if err != nil {
			panic(err)
		}

		var_Name_mapped := val.(string)

		s.Name = var_Name_mapped
	}
	if properties["order"] != nil && properties["order"].AsInterface() != nil {

		var_Order := properties["order"]
		var_Order_mapped := new(ResourceOrder)
		*var_Order_mapped = (ResourceOrder)(var_Order.GetStringValue())

		s.Order = var_Order_mapped
	}
	return s
}

func (m *ResourceIndexPropertyMapper) ToUnstructured(resourceIndexProperty *ResourceIndexProperty) unstructured.Unstructured {
	var properties unstructured.Unstructured = make(unstructured.Unstructured)

	var_Name := resourceIndexProperty.Name

	var var_Name_mapped interface{}

	var_Name_mapped = var_Name
	properties["name"] = var_Name_mapped

	var_Order := resourceIndexProperty.Order

	if var_Order != nil {
		var var_Order_mapped interface{}

		var_Order_mapped = string(*var_Order)
		properties["order"] = var_Order_mapped
	}

	return properties
}

type ResourceIndexMapper struct {
}

func NewResourceIndexMapper() *ResourceIndexMapper {
	return &ResourceIndexMapper{}
}

var ResourceIndexMapperInstance = NewResourceIndexMapper()

func (m *ResourceIndexMapper) New() *ResourceIndex {
	return &ResourceIndex{}
}

func (m *ResourceIndexMapper) ResourceIdentity() abs.ResourceIdentity {
	return abs.ResourceIdentity{
		Namespace: "system",
		Name:      "Resource",
	}
}

func (m *ResourceIndexMapper) ToProperties(resourceIndex *ResourceIndex) map[string]*structpb.Value {
	var properties = make(map[string]*structpb.Value)

	var_Properties := resourceIndex.Properties

	if var_Properties != nil {
		var var_Properties_mapped *structpb.Value

		var var_Properties_l []*structpb.Value
		for _, value := range var_Properties {

			var_5x := value
			var var_5x_mapped *structpb.Value

			var_5x_mapped = structpb.NewStructValue(&structpb.Struct{Fields: ResourceIndexPropertyMapperInstance.ToProperties(&var_5x)})

			var_Properties_l = append(var_Properties_l, var_5x_mapped)
		}
		var_Properties_mapped = structpb.NewListValue(&structpb.ListValue{Values: var_Properties_l})
		properties["properties"] = var_Properties_mapped
	}

	var_IndexType := resourceIndex.IndexType

	if var_IndexType != nil {
		var var_IndexType_mapped *structpb.Value

		var var_IndexType_err error
		var_IndexType_mapped, var_IndexType_err = types.ByResourcePropertyType(model.ResourceProperty_ENUM).Pack(string(*var_IndexType))
		if var_IndexType_err != nil {
			panic(var_IndexType_err)
		}
		properties["indexType"] = var_IndexType_mapped
	}

	var_Unique := resourceIndex.Unique

	if var_Unique != nil {
		var var_Unique_mapped *structpb.Value

		var var_Unique_err error
		var_Unique_mapped, var_Unique_err = types.ByResourcePropertyType(model.ResourceProperty_BOOL).Pack(*var_Unique)
		if var_Unique_err != nil {
			panic(var_Unique_err)
		}
		properties["unique"] = var_Unique_mapped
	}

	var_Annotations := resourceIndex.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped *structpb.Value

		var var_Annotations_st *structpb.Struct = new(structpb.Struct)
		var_Annotations_st.Fields = make(map[string]*structpb.Value)
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped *structpb.Value

			var var_1x_err error
			var_1x_mapped, var_1x_err = types.ByResourcePropertyType(model.ResourceProperty_STRING).Pack(var_1x)
			if var_1x_err != nil {
				panic(var_1x_err)
			}

			var_Annotations_st.Fields[key] = var_1x_mapped
		}
		var_Annotations_mapped = structpb.NewStructValue(var_Annotations_st)
		properties["annotations"] = var_Annotations_mapped
	}
	return properties
}

func (m *ResourceIndexMapper) FromProperties(properties map[string]*structpb.Value) *ResourceIndex {
	var s = m.New()
	if properties["properties"] != nil && properties["properties"].AsInterface() != nil {

		var_Properties := properties["properties"]
		var_Properties_mapped := []ResourceIndexProperty{}
		for _, v := range var_Properties.GetListValue().Values {

			var_4x := v
			var mappedValue = ResourceIndexPropertyMapperInstance.FromProperties(var_4x.GetStructValue().Fields)

			var_4x_mapped := *mappedValue

			var_Properties_mapped = append(var_Properties_mapped, var_4x_mapped)
		}

		s.Properties = var_Properties_mapped
	}
	if properties["indexType"] != nil && properties["indexType"].AsInterface() != nil {

		var_IndexType := properties["indexType"]
		var_IndexType_mapped := new(ResourceIndexType)
		*var_IndexType_mapped = (ResourceIndexType)(var_IndexType.GetStringValue())

		s.IndexType = var_IndexType_mapped
	}
	if properties["unique"] != nil && properties["unique"].AsInterface() != nil {

		var_Unique := properties["unique"]
		val, err := types.ByResourcePropertyType(model.ResourceProperty_BOOL).UnPack(var_Unique)

		if err != nil {
			panic(err)
		}

		var_Unique_mapped := new(bool)
		*var_Unique_mapped = val.(bool)

		s.Unique = var_Unique_mapped
	}
	if properties["annotations"] != nil && properties["annotations"].AsInterface() != nil {

		var_Annotations := properties["annotations"]
		var_Annotations_mapped := make(map[string]string)
		for k, v := range var_Annotations.GetStructValue().Fields {

			var_3x := v
			val, err := types.ByResourcePropertyType(model.ResourceProperty_STRING).UnPack(var_3x)

			if err != nil {
				panic(err)
			}

			var_3x_mapped := val.(string)

			var_Annotations_mapped[k] = var_3x_mapped
		}

		s.Annotations = var_Annotations_mapped
	}
	return s
}

func (m *ResourceIndexMapper) ToUnstructured(resourceIndex *ResourceIndex) unstructured.Unstructured {
	var properties unstructured.Unstructured = make(unstructured.Unstructured)

	var_Properties := resourceIndex.Properties

	if var_Properties != nil {
		var var_Properties_mapped interface{}

		var var_Properties_l []interface{}
		for _, value := range var_Properties {

			var_5x := value
			var var_5x_mapped interface{}

			var_5x_mapped = ResourceIndexPropertyMapperInstance.ToUnstructured(&var_5x)

			var_Properties_l = append(var_Properties_l, var_5x_mapped)
		}
		var_Properties_mapped = var_Properties_l
		properties["properties"] = var_Properties_mapped
	}

	var_IndexType := resourceIndex.IndexType

	if var_IndexType != nil {
		var var_IndexType_mapped interface{}

		var_IndexType_mapped = string(*var_IndexType)
		properties["indexType"] = var_IndexType_mapped
	}

	var_Unique := resourceIndex.Unique

	if var_Unique != nil {
		var var_Unique_mapped interface{}

		var_Unique_mapped = *var_Unique
		properties["unique"] = var_Unique_mapped
	}

	var_Annotations := resourceIndex.Annotations

	if var_Annotations != nil {
		var var_Annotations_mapped interface{}

		var var_Annotations_st map[string]interface{} = make(map[string]interface{})
		for key, value := range var_Annotations {

			var_1x := value
			var var_1x_mapped interface{}

			var_1x_mapped = var_1x

			var_Annotations_st[key] = var_1x_mapped
		}
		var_Annotations_mapped = var_Annotations_st
		properties["annotations"] = var_Annotations_mapped
	}

	return properties
}
